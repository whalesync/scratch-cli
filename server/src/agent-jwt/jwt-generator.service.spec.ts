/* eslint-disable @typescript-eslint/unbound-method */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { JwtService } from '@nestjs/jwt';
import { UserRole } from '@prisma/client';
import { ScratchpadConfigService } from 'src/config/scratchpad-config.service';
import { JwtGeneratorService } from './jwt-generator.service';
import { AgentJwtPayload } from './types';

describe('JwtGeneratorService', () => {
  let service: JwtGeneratorService;
  let jwtService: jest.Mocked<JwtService>;
  let configService: jest.Mocked<ScratchpadConfigService>;

  const mockSecret = 'test-secret-key-12345';
  const mockExpiresIn = '7d';

  beforeEach(() => {
    // Create mock JWT service
    jwtService = {
      sign: jest.fn().mockReturnValue('mock.jwt.token'),
    } as jest.Mocked<JwtService>;

    // Create mock config service
    configService = {
      getScratchpadAgentJWTSecret: jest.fn().mockReturnValue(mockSecret),
      getScratchpadAgentJWTExpiresIn: jest.fn().mockReturnValue(mockExpiresIn),
    } as jest.Mocked<ScratchpadConfigService>;

    service = new JwtGeneratorService(jwtService, configService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('generateToken', () => {
    it('should generate token with valid user payload', () => {
      const payload: AgentJwtPayload = {
        userId: 'user_123',
        role: UserRole.USER,
      };

      const token = service.generateToken(payload);

      expect(token).toBe('mock.jwt.token');
      expect(jwtService.sign).toHaveBeenCalledWith(payload, {
        secret: mockSecret,
        expiresIn: mockExpiresIn,
      });
      expect(jwtService.sign).toHaveBeenCalledTimes(1);
    });

    it('should generate token with admin role', () => {
      const payload: AgentJwtPayload = {
        userId: 'admin_456',
        role: UserRole.ADMIN,
      };

      const token = service.generateToken(payload);

      expect(token).toBe('mock.jwt.token');
      expect(jwtService.sign).toHaveBeenCalledWith(payload, {
        secret: mockSecret,
        expiresIn: mockExpiresIn,
      });
    });

    it('should retrieve secret from config service', () => {
      const payload: AgentJwtPayload = {
        userId: 'user_789',
        role: UserRole.USER,
      };

      service.generateToken(payload);

      expect(configService.getScratchpadAgentJWTSecret).toHaveBeenCalledTimes(1);
    });

    it('should retrieve expiration from config service', () => {
      const payload: AgentJwtPayload = {
        userId: 'user_789',
        role: UserRole.USER,
      };

      service.generateToken(payload);

      expect(configService.getScratchpadAgentJWTExpiresIn).toHaveBeenCalledTimes(1);
    });

    it('should use config values when signing token', () => {
      const customSecret = 'custom-secret-abc';
      const customExpiry = '30d';

      configService.getScratchpadAgentJWTSecret.mockReturnValue(customSecret);
      configService.getScratchpadAgentJWTExpiresIn.mockReturnValue(customExpiry);

      const payload: AgentJwtPayload = {
        userId: 'user_custom',
        role: UserRole.USER,
      };

      service.generateToken(payload);

      expect(jwtService.sign).toHaveBeenCalledWith(payload, {
        secret: customSecret,
        expiresIn: customExpiry,
      });
    });

    it('should handle user IDs with special characters', () => {
      const payload: AgentJwtPayload = {
        userId: 'user_with-special_chars.123',
        role: UserRole.USER,
      };

      const token = service.generateToken(payload);

      expect(token).toBe('mock.jwt.token');
      expect(jwtService.sign).toHaveBeenCalledWith(payload, {
        secret: mockSecret,
        expiresIn: mockExpiresIn,
      });
    });

    it('should handle very long user IDs', () => {
      const longUserId = 'user_' + 'a'.repeat(100);
      const payload: AgentJwtPayload = {
        userId: longUserId,
        role: UserRole.USER,
      };

      const token = service.generateToken(payload);

      expect(token).toBe('mock.jwt.token');
      expect(jwtService.sign).toHaveBeenCalledWith(
        expect.objectContaining({
          userId: longUserId,
        }),
        expect.any(Object),
      );
    });

    it('should return the token generated by JWT service', () => {
      const expectedToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.payload.signature';
      jwtService.sign.mockReturnValue(expectedToken);

      const payload: AgentJwtPayload = {
        userId: 'user_123',
        role: UserRole.USER,
      };

      const token = service.generateToken(payload);

      expect(token).toBe(expectedToken);
    });

    it('should generate different tokens for different payloads', () => {
      jwtService.sign.mockReturnValueOnce('token1').mockReturnValueOnce('token2');

      const payload1: AgentJwtPayload = {
        userId: 'user_1',
        role: UserRole.USER,
      };

      const payload2: AgentJwtPayload = {
        userId: 'user_2',
        role: UserRole.ADMIN,
      };

      const token1 = service.generateToken(payload1);
      const token2 = service.generateToken(payload2);

      expect(token1).toBe('token1');
      expect(token2).toBe('token2');
      expect(token1).not.toBe(token2);
    });

    it('should call jwtService.sign exactly once per token generation', () => {
      const payload: AgentJwtPayload = {
        userId: 'user_123',
        role: UserRole.USER,
      };

      service.generateToken(payload);
      service.generateToken(payload);
      service.generateToken(payload);

      expect(jwtService.sign).toHaveBeenCalledTimes(3);
    });

    it('should pass complete payload to JWT service without modification', () => {
      const payload: AgentJwtPayload = {
        userId: 'user_exact',
        role: UserRole.ADMIN,
      };

      service.generateToken(payload);

      expect(jwtService.sign).toHaveBeenCalledWith(
        payload,
        expect.objectContaining({
          secret: expect.any(String),
          expiresIn: expect.any(String),
        }),
      );
    });
  });
});
