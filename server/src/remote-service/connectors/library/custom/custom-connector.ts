import { ConnectorAccount, Service } from '@prisma/client';
import * as _ from 'lodash';
import { WSLogger } from 'src/logger';
import { SnapshotColumnContexts } from 'src/snapshot/types';
import { JsonSafeObject } from 'src/utils/objects';
import {
  executeCreateRecord,
  executeDeleteRecord,
  executeListTables,
  executePollRecords,
  executeSchema,
  executeUpdateRecord,
} from '../../../../custom-connector-builder/function-executor';
import { DbService } from '../../../../db/db.service';
import { Connector } from '../../connector';

import { ConnectorErrorDetails, ConnectorRecord, EntityId, PostgresColumnType, TablePreview } from '../../types';
import { CustomTableSpec } from '../custom-spec-registry';

/**
 * Custom connector is one for which all of the connector methods are generated by AI.
 * The code for each method is stored in the database and dynamically executed in a Node sandbox.
 */
export class CustomConnector extends Connector<typeof Service.CUSTOM> {
  service = Service.CUSTOM;

  private readonly userId: string;
  private readonly db: DbService;
  private readonly account: ConnectorAccount;
  constructor(
    userId: string,
    db: DbService,
    private apiKey: string,
    account: ConnectorAccount,
  ) {
    super();
    this.userId = userId;
    this.db = db;
    this.account = account;
  }

  displayName(): string {
    return 'Custom API';
  }

  public async testConnection(): Promise<void> {
    // Don't throw.
  }

  async listTables(): Promise<TablePreview[]> {
    // Get the custom connector configuration using the modifier field
    if (!this.account.modifier) {
      throw new Error('No custom connector specified for this account');
    }

    const customConnector = await this.db.client.customConnector.findUnique({
      where: { id: this.account.modifier },
      select: {
        id: true,
        name: true,
        listTables: true,
        tables: true,
      },
    });

    if (!customConnector) {
      throw new Error(`Custom connector with id ${this.account.modifier} not found`);
    }

    // If we have a listTables function, execute it to get the tables
    if (customConnector.listTables) {
      try {
        const data = await executeListTables(customConnector.listTables, this.apiKey);

        // Check if the data is in the expected format
        if (Array.isArray(data)) {
          return data.map((table) => ({
            id: {
              wsId: table.id.join(':'), // Convert array to string for wsId
              remoteId: table.id, // Keep as array for remoteId
            },
            displayName: table.displayName,
          }));
        }
      } catch (error) {
        WSLogger.error({
          source: 'CustomConnector.listTables',
          message: 'Error executing listTables function',
          error,
        });
        // Fall back to stored tables if available
      }
    }

    // Fall back to stored tables if no function or error
    if (customConnector.tables && customConnector.tables.length > 0) {
      return customConnector.tables.map((tableId: string) => {
        const parts = tableId.split(':');
        return {
          id: {
            wsId: tableId,
            remoteId: parts,
          },
          displayName: `Table ${tableId}`,
        };
      });
    }

    // If no tables found, return empty array
    return [];
  }

  async fetchTableSpec(id: EntityId): Promise<CustomTableSpec> {
    // Get the custom connector configuration using the modifier field
    if (!this.account.modifier) {
      throw new Error('No custom connector specified for this account');
    }

    const customConnector = await this.db.client.customConnector.findUnique({
      where: { id: this.account.modifier },
      select: {
        id: true,
        name: true,
        fetchSchema: true,
      },
    });

    if (!customConnector) {
      throw new Error(`Custom connector with id ${this.account.modifier} not found`);
    }

    // If we have a fetch schema function, call it to get the schema
    if (customConnector.fetchSchema) {
      try {
        const schemaData = await executeSchema(customConnector.fetchSchema, this.apiKey, id.remoteId);

        // Check if the data is in the expected schema format
        if (Array.isArray(schemaData)) {
          const columns = schemaData
            .map((schemaField: unknown) => {
              if (
                typeof schemaField === 'object' &&
                schemaField !== null &&
                'id' in schemaField &&
                'displayName' in schemaField &&
                'type' in schemaField
              ) {
                const field = schemaField as { id: string; displayName: string; type: string };
                return {
                  id: {
                    wsId: field.id,
                    remoteId: [field.id],
                  },
                  name: field.displayName,
                  pgType: field.type as PostgresColumnType,
                };
              }
              return null;
            })
            .filter((col): col is NonNullable<typeof col> => col !== null);

          return {
            id,
            name: customConnector.name,
            columns,
          };
        }
      } catch (error) {
        WSLogger.error({
          source: 'CustomConnector.fetchTableSpec',
          message: 'Error fetching table spec from schema function',
          error,
        });
        // Fall back to empty columns
      }
    }

    // Fall back to empty columns if no schema function or error
    return {
      id,
      name: customConnector.name,
      columns: [],
    };
  }

  async downloadTableRecords(
    tableSpec: CustomTableSpec,
    columnContexts: SnapshotColumnContexts,
    callback: (params: { records: ConnectorRecord[]; progress?: JsonSafeObject }) => Promise<void>,
  ): Promise<void> {
    // Get the custom connector configuration using the modifier field
    if (!this.account.modifier) {
      throw new Error('No custom connector specified for this account');
    }

    const customConnector = await this.db.client.customConnector.findUnique({
      where: { id: this.account.modifier },
      select: {
        pollRecords: true,
      },
    });

    if (!customConnector) {
      throw new Error(`Custom connector with id ${this.account.modifier} not found`);
    }

    if (!customConnector.pollRecords) {
      throw new Error('No poll records function configured for this table');
    }

    // Execute the poll records function
    let data: unknown;
    try {
      // Use the standalone execution function
      data = await executePollRecords(customConnector.pollRecords, this.apiKey, tableSpec.id.remoteId);
    } catch (error) {
      WSLogger.error({
        source: 'CustomConnector.downloadTableRecords',
        message: 'Error executing poll records function',
        error,
      });
      throw error;
    }

    // Check if the data is in the new standardized format
    if (
      Array.isArray(data) &&
      data.length > 0 &&
      typeof data[0] === 'object' &&
      data[0] !== null &&
      'id' in data[0] &&
      'fields' in data[0]
    ) {
      // Handle standardized format: { id: string, fields: { [fieldId]: value } }
      const standardizedRecords = data as Array<{ id: string; fields: Record<string, string> }>;

      // Convert to ConnectorRecord format
      const connectorRecords: ConnectorRecord[] = standardizedRecords.map((record) => ({
        id: record.id,
        fields: record.fields,
      }));

      // Call the callback with the standardized records
      await callback({ records: connectorRecords });
    } else {
      // Handle legacy format - use tableSpec columns to map the data
      const recordsArray = Array.isArray(data) ? data : [];

      const mappedRecords: ConnectorRecord[] = recordsArray.map((record, index) => {
        const mappedFields: Record<string, unknown> = {};

        // Use tableSpec columns to map the data
        for (const column of tableSpec.columns) {
          const fieldId = column.id.wsId;
          const value = _.get(record, fieldId) as unknown;
          mappedFields[fieldId] = value;
        }

        // Use the record's ID if available, otherwise fall back to index
        let recordId: string;
        if (typeof record === 'object' && record !== null && 'id' in record) {
          const recordWithId = record as { id: unknown };
          recordId = String(recordWithId.id);
        } else {
          recordId = index.toString();
        }

        return {
          id: recordId,
          fields: mappedFields,
        };
      });

      // Call the callback with the mapped records
      await callback({ records: mappedRecords });
    }
  }

  public downloadRecordDeep = undefined;

  getBatchSize(): number {
    return 10;
  }

  async createRecords(
    tableSpec: CustomTableSpec,
    columnContexts: SnapshotColumnContexts,
    records: { wsId: string; fields: Record<string, unknown> }[],
  ): Promise<{ wsId: string; remoteId: string }[]> {
    // Get the custom connector configuration using the modifier field
    if (!this.account.modifier) {
      throw new Error('No custom connector specified for this account');
    }

    const customConnector = await this.db.client.customConnector.findUnique({
      where: { id: this.account.modifier },
      select: {
        createRecord: true,
      },
    });

    if (!customConnector) {
      throw new Error(`Custom connector with id ${this.account.modifier} not found`);
    }

    if (!customConnector.createRecord) {
      throw new Error('No create function configured for this table');
    }

    const results: { wsId: string; remoteId: string }[] = [];

    try {
      // Execute the create function for each record
      for (const record of records) {
        try {
          // Use the standalone execution function
          const result = await executeCreateRecord(
            customConnector.createRecord,
            record.fields,
            this.apiKey,
            tableSpec.id.remoteId,
          );
          WSLogger.debug({ source: 'CustomConnector.createRecords', message: 'Successfully created record', record });

          // Extract the created record ID from the result
          let remoteId: string;
          if (typeof result === 'object' && result !== null && 'id' in result) {
            remoteId = String((result as { id: unknown }).id);
          } else if (typeof result === 'string') {
            remoteId = result;
          } else {
            // Fallback to wsId if no ID in response
            remoteId = record.wsId;
          }

          results.push({
            wsId: record.wsId,
            remoteId,
          });
        } catch (error) {
          WSLogger.error({
            source: 'CustomConnector.createRecords',
            message: 'Failed to create record',
            recordId: record.wsId,
            error,
          });
          throw error instanceof Error ? error : new Error(String(error));
        }
      }

      WSLogger.debug({
        source: 'CustomConnector.createRecords',
        message: 'Successfully processed create operation',
        records,
      });
      return results;
    } catch (error) {
      WSLogger.error({
        source: 'CustomConnector.createRecords',
        message: 'Error executing dynamic create function',
        error,
      });
      throw error;
    }
  }

  async updateRecords(
    tableSpec: CustomTableSpec,
    _columnContexts: SnapshotColumnContexts,
    records: {
      id: { wsId: string; remoteId: string };
      partialFields: Record<string, unknown>;
    }[],
  ): Promise<void> {
    // Get the custom connector configuration using the modifier field
    if (!this.account.modifier) {
      throw new Error('No custom connector specified for this account');
    }

    const customConnector = await this.db.client.customConnector.findUnique({
      where: { id: this.account.modifier },
      select: {
        updateRecord: true,
      },
    });

    if (!customConnector) {
      throw new Error(`Custom connector with id ${this.account.modifier} not found`);
    }

    if (!customConnector.updateRecord) {
      throw new Error('No update function configured for this table');
    }

    try {
      // Execute the update function for each record
      for (const record of records) {
        try {
          // Use the standalone execution function
          await executeUpdateRecord(
            customConnector.updateRecord,
            record.id.remoteId,
            record.partialFields,
            this.apiKey,
            tableSpec.id.remoteId,
          );
          WSLogger.debug({
            source: 'CustomConnector.updateRecords',
            message: 'Successfully updated record',
            record,
          });
        } catch (error) {
          WSLogger.error({
            source: 'CustomConnector.updateRecords',
            message: 'Failed to update record',
            recordId: record.id.remoteId,
            error,
          });
          throw error instanceof Error ? error : new Error(String(error));
        }
      }

      WSLogger.debug({
        source: 'CustomConnector.updateRecords',
        message: 'Successfully processed update operation',
        records,
      });
    } catch (error) {
      WSLogger.error({
        source: 'CustomConnector.updateRecords',
        message: 'Error executing dynamic update function',
        error,
      });
      throw error;
    }
  }

  async deleteRecords(tableSpec: CustomTableSpec, recordIds: { wsId: string; remoteId: string }[]): Promise<void> {
    // Get the custom connector configuration using the modifier field
    if (!this.account.modifier) {
      throw new Error('No custom connector specified for this account');
    }

    const customConnector = await this.db.client.customConnector.findUnique({
      where: { id: this.account.modifier },
      select: {
        deleteRecord: true,
      },
    });

    if (!customConnector) {
      throw new Error(`Custom connector with id ${this.account.modifier} not found`);
    }

    if (!customConnector.deleteRecord) {
      throw new Error('No delete function configured for this table');
    }

    try {
      // Execute the delete function for each record
      for (const recordId of recordIds) {
        try {
          // Use the standalone execution function
          await executeDeleteRecord(
            customConnector.deleteRecord,
            recordId.remoteId,
            this.apiKey,
            tableSpec.id.remoteId,
          );
          WSLogger.debug({
            source: 'CustomConnector.deleteRecords',
            message: 'Successfully deleted record',
            recordId,
          });
        } catch (error) {
          WSLogger.error({
            source: 'CustomConnector.deleteRecords',
            message: 'Failed to delete record',
            recordId,
            error,
          });
          throw error;
        }
      }

      WSLogger.debug({
        source: 'CustomConnector.deleteRecords',
        message: 'Successfully processed delete operation',
        recordIds,
      });
    } catch (error) {
      WSLogger.error({
        source: 'CustomConnector.deleteRecords',
        message: 'Error executing dynamic delete function',
        error,
      });
      throw error;
    }
  }

  // Record fields need to be keyed by the remoteId, not the wsId.
  // private wsFieldsToAirtableFields(
  //   wsFields: Record<string, unknown>,
  //   tableSpec: CustomTableSpec,
  // ): Record<string, unknown> {
  //   const airtableFields: Record<string, unknown> = {};
  //   for (const column of tableSpec.columns) {
  //     if (column.id.wsId === 'id') {
  //       continue;
  //     }
  //     const val = wsFields[column.id.wsId];
  //     if (val !== undefined) {
  //       if (column.pgType === PostgresColumnType.NUMERIC) {
  //         airtableFields[column.id.remoteId[0]] = parseFloat(val as string);
  //       } else {
  //         airtableFields[column.id.remoteId[0]] = val;
  //       }
  //     }
  //   }
  //   return airtableFields;
  // }

  extractConnectorErrorDetails(error: unknown): ConnectorErrorDetails {
    return {
      userFriendlyMessage: 'An error occurred while connecting to the custom API',
      description: error instanceof Error ? error.message : String(error),
    };
  }
}
