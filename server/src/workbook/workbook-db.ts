/* eslint-disable @typescript-eslint/require-await */
import {
  createSnapshotRecordId,
  RecordOperation,
  SnapshotRecordId,
  UNPUBLISHED_PREFIX,
  WorkbookId,
} from '@spinner/shared-types';
import matter from 'gray-matter';
import { Knex } from 'knex';
import {
  BaseColumnSpec,
  BaseTableSpec,
  ConnectorRecord,
  RecordErrorsMetadata,
  SnapshotRecord,
} from '../remote-service/connectors/types';

// Table name constant
export const FILES_TABLE = 'files';

// Column name constants for the files table

// The internal unique identifier for the file
export const SCRATCH_ID_COLUMN = 'id';

// The remote identifier for the file if linked to a remote source
export const REMOTE_ID_COLUMN = 'remote_id';

// The folder the file belongs to
export const FOLDER_ID_COLUMN = 'folder_id';

// The name of the file
export const NAME_COLUMN = 'name';

// The active content of the file, as it appears in the UI
export const CONTENT_COLUMN = 'content';

// The original content of the file, as it was when it was first created or pulled from the remote source.
export const ORIGINAL_COLUMN = 'original';

// The suggested content of the file, as generated by the agent
export const SUGGESTED_COLUMN = 'suggested';

// The flag indicating that the file was deleted by the agent and is pending acceptance by the user
export const SUGGESTED_DELETE_COLUMN = 'suggested_delete';

// Index of non-body Front Matter properties stored as key-value pairs. We can use JSON queries to create filters and sort
export const METADATA_COLUMN = 'metadata';

// The timestamp when the file was created
export const CREATED_AT_COLUMN = 'created_at';

// The timestamp when the file was last updated
export const UPDATED_AT_COLUMN = 'updated_at';

// The flag indicating that the file was deleted by the user and should get deleted from the remote source
export const DELETED_COLUMN = 'deleted';

// The flag indicating that the file has been modified since the original content was set
export const DIRTY_COLUMN = 'dirty';

// A JSON object containing connector-specific errors for the file
export const ERRORS_COLUMN = 'errors';

// tracks seen state for the file during sync operations
export const SEEN_COLUMN = 'seen';

/**
 * Different states of a file record
 * - new file (suggestion): suggested content <> null, original content === null
 * - new file (accepted): content <> null, original content === null
 * - deleted: deleted === true
 * - deleted (suggested): suggested_delete === true, suggested content <> null (i.e. set to '')
 * - modified: content <> original content
 * - pending change: suggested <> null && suggested <> content
 * - dirty: the file record has changed since the original content was set. Just a quick filter flag
 */

/**
 * Represents a single file record from the files table
 */
export type FileDbRecord = {
  [SCRATCH_ID_COLUMN]: string;
  [REMOTE_ID_COLUMN]: string | null;
  [FOLDER_ID_COLUMN]: string;
  [NAME_COLUMN]: string;
  [CONTENT_COLUMN]: string | null;
  [ORIGINAL_COLUMN]: string | null;
  [SUGGESTED_COLUMN]: string | null;
  [METADATA_COLUMN]: Record<string, unknown>;
  [CREATED_AT_COLUMN]: Date;
  [UPDATED_AT_COLUMN]: Date;
  [DELETED_COLUMN]: boolean;
  [SUGGESTED_DELETE_COLUMN]: boolean;
  [DIRTY_COLUMN]: boolean;
  [ERRORS_COLUMN]: Record<string, unknown>;
  [SEEN_COLUMN]: boolean;
};

export class WorkbookDb {
  public knex!: Knex;

  init(knex: Knex) {
    this.knex = knex;
  }

  /**
   * Creates a new schema for a workbook and creates the files table within it
   */
  async createForWorkbook(workbookId: WorkbookId) {
    // Create the schema if it doesn't exist
    await this.getKnex().raw(`CREATE SCHEMA IF NOT EXISTS "${workbookId}"`);

    // Check if the files table already exists
    const tableExists = await this.getKnex().schema.withSchema(workbookId).hasTable(FILES_TABLE);

    if (!tableExists) {
      // Create the files table
      await this.getKnex()
        .schema.withSchema(workbookId)
        .createTable(FILES_TABLE, (t) => {
          t.text(SCRATCH_ID_COLUMN).primary();
          t.text(REMOTE_ID_COLUMN).nullable().index();
          t.text(FOLDER_ID_COLUMN).index();
          t.text(NAME_COLUMN);
          t.text(CONTENT_COLUMN).nullable();
          t.text(ORIGINAL_COLUMN).nullable();
          t.text(SUGGESTED_COLUMN).nullable();
          t.jsonb(METADATA_COLUMN).defaultTo('{}');
          t.timestamp(CREATED_AT_COLUMN, { useTz: false }).defaultTo(this.getKnex().fn.now());
          t.timestamp(UPDATED_AT_COLUMN, { useTz: false }).defaultTo(this.getKnex().fn.now());
          t.boolean(DELETED_COLUMN).defaultTo(false);
          t.boolean(SUGGESTED_DELETE_COLUMN).defaultTo(false);
          t.boolean(DIRTY_COLUMN).defaultTo(false);
          t.jsonb(ERRORS_COLUMN).defaultTo('{}');
          t.boolean(SEEN_COLUMN).defaultTo(false);
        });
    }
  }

  /**
   * Returns all FileDbRecords for a specific folder
   */
  async listFiles(
    workbookId: WorkbookId,
    folderId: string,
    skip: number,
    take: number,
    sqlFilter?: string | null,
  ): Promise<{ files: SnapshotRecord[]; count: number; filteredCount: number; skip: number; take: number }> {
    const query = this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(FOLDER_ID_COLUMN, folderId)
      .orderBy(SCRATCH_ID_COLUMN, 'asc')
      .limit(take)
      .offset(skip);

    // Apply SQL filter if provided
    if (sqlFilter && sqlFilter.trim() !== '') {
      query.whereRaw(sqlFilter);
    }

    query.select('*');

    const result = await query;

    // Calculate counts
    let count: number;
    let filteredCount: number;

    if (sqlFilter && sqlFilter.trim() !== '') {
      // Count total files in folder without filter
      const totalQuery = this.getKnex()(FILES_TABLE).withSchema(workbookId).where(FOLDER_ID_COLUMN, folderId);
      const totalFiles = await totalQuery.count('* as count');
      count = parseInt(String(totalFiles[0].count), 10);

      // Count filtered files with filter
      const filteredQuery = this.getKnex()(FILES_TABLE).withSchema(workbookId).where(FOLDER_ID_COLUMN, folderId);
      filteredQuery.whereRaw(sqlFilter);
      const filteredFiles = await filteredQuery.count('* as count');
      filteredCount = parseInt(String(filteredFiles[0].count), 10);
    } else {
      // No filter, so both counts are the same
      const totalQuery = this.getKnex()(FILES_TABLE).withSchema(workbookId).where(FOLDER_ID_COLUMN, folderId);
      const totalFiles = await totalQuery.count('* as count');
      count = parseInt(String(totalFiles[0].count), 10);
      filteredCount = count;
    }

    const files = result.map((r) => convertFileDbRecordToSnapshotRecord(r));
    return {
      files,
      count,
      filteredCount,
      skip,
      take,
    };
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async listFilesAndFolders(workbookId: WorkbookId, parentFolderPath: string): Promise<FileDbRecord[]> {
    // TODO:
    throw new Error('Not yet implemented');
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async getFileByPath(workbookId: WorkbookId, fullPath: string): Promise<FileDbRecord | null> {
    // TODO:
    throw new Error('Not yet implemented');
  }

  private async getFileRecord(workbookId: WorkbookId, fileId: string): Promise<FileDbRecord | undefined> {
    return this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(SCRATCH_ID_COLUMN, fileId)
      .select('*')
      .first();
  }

  /**
   * Returns a single FileDbRecord for a unique ID
   */
  async getFile(workbookId: WorkbookId, fileId: string): Promise<SnapshotRecord | null> {
    const result = await this.getFileRecord(workbookId, fileId);
    return result ? convertFileDbRecordToSnapshotRecord(result) : null;
  }

  async getFileRemotId(workbookId: WorkbookId, folderId: string, remoteId: string): Promise<SnapshotRecord[]> {
    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(FOLDER_ID_COLUMN, folderId)
      .where(REMOTE_ID_COLUMN, remoteId)
      .select('*');

    return result.map((r) => convertFileDbRecordToSnapshotRecord(r));
  }
  /**
   * Returns FileDbRecords for a list of scratch IDs
   */
  async getFilesById(workbookId: WorkbookId, fileIds: string[]): Promise<FileDbRecord[]> {
    if (fileIds.length === 0) {
      return [];
    }

    const results = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .whereIn(SCRATCH_ID_COLUMN, fileIds)
      .select('*');

    return results;
  }

  /**
   * Accepts suggestions for a list of file IDs
   * Copies the suggested column value to content, sets suggested to null, and updates the timestamp
   * Only updates files where suggested is not null
   */
  async acceptSuggestions(workbookId: WorkbookId, fileIds: string[]): Promise<number> {
    if (fileIds.length === 0) {
      return 0;
    }

    // TODO: this needs to handle the suggested creates/deletes properly, setting the appropriate columns and timestamps

    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .whereIn(SCRATCH_ID_COLUMN, fileIds)
      .whereNotNull(SUGGESTED_COLUMN)
      .update({
        [CONTENT_COLUMN]: this.getKnex().raw('??', [SUGGESTED_COLUMN]),
        [SUGGESTED_COLUMN]: null,
        [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
      });

    return result;
  }

  /**
   * Rejects suggestions for a list of file IDs
   * Sets the suggested column to null and clears the suggested_delete flag without updating content
   * Only updates files where suggested is not null
   */
  async rejectSuggestions(workbookId: WorkbookId, fileIds: string[]): Promise<number> {
    if (fileIds.length === 0) {
      return 0;
    }

    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .whereIn(SCRATCH_ID_COLUMN, fileIds)
      .whereNotNull(SUGGESTED_COLUMN)
      .update({
        [SUGGESTED_COLUMN]: null,
        [SUGGESTED_DELETE_COLUMN]: false,
      });

    return result;
  }

  /**
   * Accepts suggestions for all files in a folder
   * Copies the suggested column value to content, sets suggested to null, and updates the timestamp
   * Only updates files where suggested is not null
   */
  async acceptSuggestionsForFolder(workbookId: WorkbookId, folderId: string): Promise<number> {
    // TODO: this needs to handle the suggested creates/deletes properly, setting the appropriate columns and timestamps

    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(FOLDER_ID_COLUMN, folderId)
      .whereNotNull(SUGGESTED_COLUMN)
      .update({
        [CONTENT_COLUMN]: this.getKnex().raw('??', [SUGGESTED_COLUMN]),
        [SUGGESTED_COLUMN]: null,
        [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
      });

    return result;
  }

  /**
   * Rejects suggestions for all files in a folder
   * Sets the suggested column to null and clears the suggested_delete flag without updating content
   * Only updates files where suggested is not null
   */
  async rejectSuggestionsForFolder(workbookId: WorkbookId, folderId: string): Promise<number> {
    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(FOLDER_ID_COLUMN, folderId)
      .whereNotNull(SUGGESTED_COLUMN)
      .update({
        [SUGGESTED_COLUMN]: null,
        [SUGGESTED_DELETE_COLUMN]: false,
      });

    return result;
  }

  /**
   * Moves a file to a different folder
   */
  async moveFile(workbookId: WorkbookId, fileId: string, newFolderId: string): Promise<void> {
    await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(SCRATCH_ID_COLUMN, fileId)
      .update({
        [FOLDER_ID_COLUMN]: newFolderId,
        [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
      });
  }

  /**
   * Renames a file and updates the corresponding metadata field in the frontmatter content.
   * Only updates the content column, leaving the original column unchanged.
   *
   * @param workbookId - The workbook ID
   * @param fileId - The file ID to rename
   * @param newName - The new name for the file
   * @param titleFieldName - Optional: The name of the metadata field that stores the title (if known)
   */
  async renameFile(workbookId: WorkbookId, fileId: string, newName: string, titleFieldName?: string): Promise<void> {
    const file = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(SCRATCH_ID_COLUMN, fileId)
      .select('*')
      .first();

    // Get the current file
    if (!file) {
      throw new Error(`File with id ${fileId} not found`);
    }

    // If titleFieldName is provided, update the frontmatter content
    let updatedContent = file[CONTENT_COLUMN];

    if (titleFieldName && updatedContent) {
      updatedContent = updateFrontmatterMetadata(updatedContent, titleFieldName, newName);
    }

    // Update the file
    await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(SCRATCH_ID_COLUMN, fileId)
      .update({
        [NAME_COLUMN]: newName,
        [CONTENT_COLUMN]: updatedContent,
        [DIRTY_COLUMN]: true,
        [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
      });
  }

  /**
   * Copies a file to another folder
   * Creates a new ID but preserves the remote ID
   * If copying to the same folder, adds " (copy)" suffix to the name
   */
  async copyFile(workbookId: WorkbookId, fileId: string, targetFolderId: string): Promise<string> {
    // Get the source file
    const sourceFile = await this.getFileRecord(workbookId, fileId);
    if (!sourceFile) {
      throw new Error(`File with id ${fileId} not found`);
    }

    const newScratchId = createSnapshotRecordId();
    const isSameFolder = sourceFile[FOLDER_ID_COLUMN] === targetFolderId;
    const newName = isSameFolder ? `${sourceFile[NAME_COLUMN]} (copy)` : sourceFile[NAME_COLUMN];

    // Insert the copied file
    await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .insert({
        [SCRATCH_ID_COLUMN]: newScratchId,
        [REMOTE_ID_COLUMN]: sourceFile[REMOTE_ID_COLUMN],
        [FOLDER_ID_COLUMN]: targetFolderId,
        [NAME_COLUMN]: newName,
        [CONTENT_COLUMN]: sourceFile[CONTENT_COLUMN], // QUESTION: should we copy the original content here or leave it as null?
        [ORIGINAL_COLUMN]: sourceFile[ORIGINAL_COLUMN],
        [SUGGESTED_COLUMN]: sourceFile[SUGGESTED_COLUMN],
        [METADATA_COLUMN]: sourceFile[METADATA_COLUMN],
        [CREATED_AT_COLUMN]: this.getKnex().fn.now(),
        [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
        [DELETED_COLUMN]: false,
        [DIRTY_COLUMN]: sourceFile[DIRTY_COLUMN], // Preserve dirty state of source file
        [ERRORS_COLUMN]: sourceFile[ERRORS_COLUMN],
        [SEEN_COLUMN]: false,
        [SUGGESTED_DELETE_COLUMN]: sourceFile[SUGGESTED_DELETE_COLUMN],
      });

    return newScratchId;
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async createFileByPath(workbookId: WorkbookId, fullPath: string, content: string | null): Promise<string> {
    // TODO:
    throw new Error('Not yet implemented');
  }

  async updateFileByPath(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    workbookId: WorkbookId,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    currentPath: string,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updates: {
      newPath?: string; // If provided, rename/move the file
      content?: string | null;
    },
  ): Promise<void> {
    // TODO:
    throw new Error('Not yet implemented');
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async deleteFileByPath(workbookId: WorkbookId, filePath: string): Promise<void> {
    // TODO:
    throw new Error('Not yet implemented');
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async renameFolder(workbookId: WorkbookId, oldFolderPath: string, newFolderPath: string): Promise<number> {
    // TODO:
    throw new Error('Not yet implemented');
  }

  /**
   * Bulk update files with create, update, delete, and undelete operations
   * The data in RecordOperation will have a single property named 'content'
   */
  async bulkUpdateFiles(
    workbookId: WorkbookId,
    folderId: string,
    ops: RecordOperation[],
    type: 'suggested' | 'accepted',
  ): Promise<void> {
    await this.getKnex().transaction(async (trx) => {
      for (const op of ops) {
        switch (op.op) {
          case 'create': {
            const content = op.data?.content as string | null | undefined;

            const scratchId = createSnapshotRecordId();
            const tempRemoteId = `${UNPUBLISHED_PREFIX}${scratchId}`;
            await trx(FILES_TABLE)
              .withSchema(workbookId)
              .insert({
                [SCRATCH_ID_COLUMN]: scratchId,
                [REMOTE_ID_COLUMN]: tempRemoteId,
                [FOLDER_ID_COLUMN]: folderId,
                [NAME_COLUMN]: '', // Default empty name, should be set by caller
                ...(type === 'accepted'
                  ? {
                      [CONTENT_COLUMN]: content ?? null,
                      [SUGGESTED_COLUMN]: null,
                      [UPDATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
                      [CREATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
                      [DIRTY_COLUMN]: true,
                    }
                  : {
                      [CONTENT_COLUMN]: null,
                      [SUGGESTED_COLUMN]: content ?? null,
                      [UPDATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
                      [CREATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
                    }),
              });
            break;
          }
          case 'update': {
            const content = op.data?.content as string | null | undefined;

            if (type === 'accepted') {
              await trx(FILES_TABLE)
                .withSchema(workbookId)
                .where(SCRATCH_ID_COLUMN, op.wsId)
                .update({
                  [CONTENT_COLUMN]: content ?? null,
                  [UPDATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
                  [DIRTY_COLUMN]: true,
                });
            } else {
              await trx(FILES_TABLE)
                .withSchema(workbookId)
                .where(SCRATCH_ID_COLUMN, op.wsId)
                .update({
                  [SUGGESTED_COLUMN]: content ?? null,
                  [UPDATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
                });
            }
            break;
          }
          case 'delete': {
            if (type === 'accepted') {
              // First check if the record has original content
              const record = await trx(FILES_TABLE)
                .withSchema(workbookId)
                .where(SCRATCH_ID_COLUMN, op.wsId)
                .first<{ [ORIGINAL_COLUMN]: string | null }>();

              if (record?.[ORIGINAL_COLUMN] !== null) {
                // Record has original content, flag it for deletion
                await trx(FILES_TABLE)
                  .withSchema(workbookId)
                  .where(SCRATCH_ID_COLUMN, op.wsId)
                  .update({
                    [DELETED_COLUMN]: true,
                    [DIRTY_COLUMN]: true,
                    [UPDATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
                  });
              } else {
                // No original content, delete from table
                await trx(FILES_TABLE).withSchema(workbookId).where(SCRATCH_ID_COLUMN, op.wsId).delete();
              }
            } else {
              // Suggested delete: set suggested column to empty string and set suggested_delete flag
              await trx(FILES_TABLE)
                .withSchema(workbookId)
                .where(SCRATCH_ID_COLUMN, op.wsId)
                .update({
                  [SUGGESTED_COLUMN]: '',
                  [SUGGESTED_DELETE_COLUMN]: true,
                  [UPDATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
                });
            }
            break;
          }
          case 'undelete': {
            if (type === 'accepted') {
              // Unmark for deletion
              await trx(FILES_TABLE)
                .withSchema(workbookId)
                .where(SCRATCH_ID_COLUMN, op.wsId)
                .update({
                  [DELETED_COLUMN]: false,
                  [UPDATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
                });
            } else {
              // For suggested undelete, just clear the deleted flag
              await trx(FILES_TABLE)
                .withSchema(workbookId)
                .where(SCRATCH_ID_COLUMN, op.wsId)
                .update({
                  [DELETED_COLUMN]: false,
                  [UPDATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
                });
            }
            break;
          }
        }
      }
    });
  }

  /**
   * Upserts files from an array of ConnectorRecord objects.
   * Converts each ConnectorRecord to Front Matter markdown format.
   * The main content body is extracted from the field specified by mainContentColumnRemoteId in the TableSpec.
   * All other fields are stored as metadata in the YAML front matter.
   *
   * @param workbookId - The workbook ID
   * @param folderId - The folder ID where files will be stored
   * @param records - Array of ConnectorRecord objects to upsert
   * @param tableSpec - TableSpec containing column definitions and mainContentColumnRemoteId
   * @returns Promise that resolves when all files have been upserted
   */
  async upsertFilesFromConnectorRecords<T extends BaseColumnSpec>(
    workbookId: WorkbookId,
    folderId: string,
    records: ConnectorRecord[],
    tableSpec: BaseTableSpec<T>,
  ): Promise<void> {
    await this.getKnex().transaction(async (trx) => {
      for (const record of records) {
        // Convert to Front Matter markdown format
        const frontMatterContent = convertConnectorRecordToFrontmatter(record, tableSpec);

        // Generate a scratch ID for new records
        const scratchId = createSnapshotRecordId();

        // Determine the file name - use title column if available, otherwise use the record ID
        let fileName = record.id;
        if (tableSpec.titleColumnRemoteId) {
          const titleColumn = tableSpec.columns.find((col) => col.id.remoteId === tableSpec.titleColumnRemoteId);
          if (titleColumn) {
            const titleValue = record.fields[titleColumn.id.wsId];
            if (titleValue && typeof titleValue === 'string') {
              fileName = titleValue;
            }
          }
        }

        // Check if file with this remote_id already exists
        const existingFile = await trx<FileDbRecord>(FILES_TABLE)
          .withSchema(workbookId)
          .where(REMOTE_ID_COLUMN, record.id)
          .where(FOLDER_ID_COLUMN, folderId)
          .first();

        if (existingFile) {
          // Update existing file
          await trx(FILES_TABLE)
            .withSchema(workbookId)
            .where(SCRATCH_ID_COLUMN, existingFile[SCRATCH_ID_COLUMN])
            .update({
              [ORIGINAL_COLUMN]: frontMatterContent, // this resets the original content new value from the connector
              [CONTENT_COLUMN]: frontMatterContent,
              [NAME_COLUMN]: fileName,
              [DIRTY_COLUMN]: false, // Reset dirty flag since content matches remote
              [ERRORS_COLUMN]: record.errors || {},
              [UPDATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
            });
        } else {
          // Insert new file
          await trx(FILES_TABLE)
            .withSchema(workbookId)
            .insert({
              [SCRATCH_ID_COLUMN]: scratchId,
              [REMOTE_ID_COLUMN]: record.id,
              [FOLDER_ID_COLUMN]: folderId,
              [NAME_COLUMN]: fileName,
              [CONTENT_COLUMN]: frontMatterContent,
              [ORIGINAL_COLUMN]: frontMatterContent,
              [SUGGESTED_COLUMN]: null,
              [CREATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
              [UPDATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
              [DELETED_COLUMN]: false,
              [DIRTY_COLUMN]: false, // New files from connector are clean
              [ERRORS_COLUMN]: record.errors || {},
            });
        }
      }
    });
  }

  async resetSeenFlagForFolder(workbookId: WorkbookId, folderId: string): Promise<void> {
    await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(FOLDER_ID_COLUMN, folderId)
      .update({ [SEEN_COLUMN]: false });
  }

  public getKnex(): Knex {
    if (!this.knex) {
      throw new Error('Expected knex to not be undefined');
    }
    return this.knex;
  }
}

/************************
 *
 * Utility functions
 *
 * *************************/

/**
 * Converts a ConnectorRecord to Front Matter markdown format.
 * The main content body is extracted from the field specified by mainContentColumnRemoteId in the TableSpec.
 * All other fields are stored as metadata in the YAML front matter.
 *
 * @param record - The ConnectorRecord to convert
 * @param tableSpec - TableSpec containing column definitions and mainContentColumnRemoteId
 * @returns Front Matter markdown string
 */
export function convertConnectorRecordToFrontmatter<T extends BaseColumnSpec>(
  record: ConnectorRecord,
  tableSpec: BaseTableSpec<T>,
): string {
  // Determine the main content column key
  let mainContentKey: string | undefined;
  if (tableSpec.mainContentColumnRemoteId) {
    // Find the column with matching remoteId
    const column = tableSpec.columns.find((col) => col.id.remoteId === tableSpec.mainContentColumnRemoteId);
    mainContentKey = column?.id.wsId;
  }

  // Extract main content and metadata from record fields
  let bodyContent = '';
  const metadata: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(record.fields)) {
    if (mainContentKey && key === mainContentKey) {
      // This is the main content field
      bodyContent =
        typeof value === 'string' ? value : value === null || value === undefined ? '' : JSON.stringify(value, null, 2);
    } else {
      // All other fields go to metadata
      metadata[key] = value;
    }
  }

  // Convert to Front Matter markdown format
  return matter.stringify(bodyContent, metadata);
}

/**
 * Updates a metadata field in frontmatter content.
 *
 * @param frontmatterContent - The current frontmatter markdown content
 * @param fieldName - The name of the metadata field to update
 * @param newValue - The new value for the field
 * @returns Updated frontmatter markdown string
 */
export function updateFrontmatterMetadata(
  frontmatterContent: string | null,
  fieldName: string,
  newValue: unknown,
): string {
  if (!frontmatterContent) {
    // If no content, create new frontmatter with just the field
    return matter.stringify('', { [fieldName]: newValue });
  }

  // Parse existing frontmatter
  const parsed = matter(frontmatterContent);
  const metadata = parsed.data as Record<string, unknown>;

  // Update the specific field
  metadata[fieldName] = newValue;

  // Reconstruct frontmatter
  return matter.stringify(parsed.content, metadata);
}

/**
 * Converts a FileDbRecord into a SnapshotRecord.
 * The content column value is mapped to a single property in the fields object.
 * If the suggested column is not null, it is included in __suggested_values.
 *
 * @param fileRecord - The FileDbRecord to convert
 * @returns A SnapshotRecord
 */
export function convertFileDbRecordToSnapshotRecord(fileRecord: FileDbRecord): SnapshotRecord {
  const fields: Record<string, unknown> = { content: fileRecord[CONTENT_COLUMN] };
  const suggestedValues: Record<string, unknown> = { content: fileRecord[SUGGESTED_COLUMN] ?? undefined };
  if (fileRecord[SUGGESTED_DELETE_COLUMN]) {
    suggestedValues['__deleted'] = fileRecord.updated_at;
  }

  return {
    id: {
      wsId: fileRecord[SCRATCH_ID_COLUMN] as SnapshotRecordId,
      remoteId: fileRecord[REMOTE_ID_COLUMN],
    },
    fields,
    __edited_fields: {},
    __suggested_values: suggestedValues,
    __fields: {},
    __metadata: {},
    __errors: (fileRecord[ERRORS_COLUMN] as RecordErrorsMetadata) || {},
    __dirty: fileRecord[DIRTY_COLUMN],
    __old_remote_id: null,
  };
}
