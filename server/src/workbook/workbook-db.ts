/* eslint-disable @typescript-eslint/require-await */
import { createFileId, FileId, SnapshotTableId, UNPUBLISHED_PREFIX, WorkbookId } from '@spinner/shared-types';
import matter from 'gray-matter';
import { Knex } from 'knex';
import _ from 'lodash';
import path from 'path';
import { WSLogger } from 'src/logger';
import { BaseColumnSpec, BaseTableSpec, ConnectorRecord } from '../remote-service/connectors/types';

// Table name constant
export const FILES_TABLE = 'files';

// Column name constants for the files table

// The internal unique identifier for the file
export const FILE_ID_COLUMN = 'id';

// The remote identifier for the file if linked to a remote source
export const REMOTE_ID_COLUMN = 'remote_id';

// The folder the file belongs to, used to perform folder-scoped operations on files without needind to string-match the path
export const FOLDER_ID_COLUMN = 'folder_id';

// The full path of the file in the folder hierarchy including all of the folders and ending with the file name
export const PATH_COLUMN = 'path';

// A generated value based on the path, providing the name of the folder this file belongs to.
// Until we implement folder slugs, this will be the same as the folder_id
// NOTE: this might be redundant give we could pull the value from the path column instead
export const FOLDER_NAME_COLUMN = 'folder';

// A generated value based on the path, providing the name of the file
// File name is managed by scratch though the initial value may be sourced from a title or name field in the connector record
export const FILE_NAME_COLUMN = 'name';

// The active content of the file, as it appears in the UI
export const CONTENT_COLUMN = 'content';

// The original content of the file, as it was when it was first created or pulled from the remote source.
export const ORIGINAL_COLUMN = 'original';

// The suggested content of the file, as generated by the agent
export const SUGGESTED_COLUMN = 'suggested';

// The flag indicating that the file was deleted by the agent and is pending acceptance by the user
export const SUGGESTED_DELETE_COLUMN = 'suggested_delete';

// Index of non-body Front Matter properties stored as key-value pairs. We can use JSON queries to create filters and sort
export const METADATA_COLUMN = 'metadata';

// The timestamp when the file was created
export const CREATED_AT_COLUMN = 'created_at';

// The timestamp when the file was last updated
export const UPDATED_AT_COLUMN = 'updated_at';

// The flag indicating that the file was deleted by the user and should get deleted from the remote source
export const DELETED_COLUMN = 'deleted';

// The flag indicating that the file has been modified since the original content was set
export const DIRTY_COLUMN = 'dirty';

// A JSON object containing connector-specific errors for the file
export const ERRORS_COLUMN = 'errors';

// tracks seen state for the file during sync operations
export const SEEN_COLUMN = 'seen';

export const FILE_PATH_PREFIX = '/';

/**
 * Different states of a file record
 * - new file (suggestion): suggested <> null, original === null
 * - new file (accepted): content <> null, original === null
 * - deleted: deleted === true
 * - deleted (suggested): suggested_delete === true, suggested  === ''
 * - modified: content <> original
 * - pending change: suggested <> null && suggested <> content
 * - dirty: the file record has changed since the original content was set. Just a quick filter flag
 */

/**
 * Represents a single file record from the files table
 */
export type FileDbRecord = {
  [FILE_ID_COLUMN]: string;
  [REMOTE_ID_COLUMN]: string | null;
  [FOLDER_ID_COLUMN]: string;
  [PATH_COLUMN]: string;
  [FOLDER_NAME_COLUMN]: string;
  [FILE_NAME_COLUMN]: string;
  [CONTENT_COLUMN]: string | null;
  [ORIGINAL_COLUMN]: string | null;
  [SUGGESTED_COLUMN]: string | null;
  [METADATA_COLUMN]: Record<string, unknown>;
  [CREATED_AT_COLUMN]: Date;
  [UPDATED_AT_COLUMN]: Date;
  [DELETED_COLUMN]: boolean;
  [SUGGESTED_DELETE_COLUMN]: boolean;
  [DIRTY_COLUMN]: boolean;
  [ERRORS_COLUMN]: Record<string, unknown>;
  [SEEN_COLUMN]: boolean;
};

const MAX_UNIQUE_FILE_NAME_ATTEMPTS = 20;

export class WorkbookDb {
  public knex!: Knex;

  init(knex: Knex) {
    this.knex = knex;
  }

  /**
   * Creates a new schema for a workbook and creates the files table within it
   */
  async createForWorkbook(workbookId: WorkbookId) {
    // Create the schema if it doesn't exist
    await this.getKnex().raw(`CREATE SCHEMA IF NOT EXISTS "${workbookId}"`);

    // Check if the files table already exists
    const tableExists = await this.getKnex().schema.withSchema(workbookId).hasTable(FILES_TABLE);

    if (!tableExists) {
      // Create the central files table
      await this.getKnex()
        .schema.withSchema(workbookId)
        .createTable(FILES_TABLE, (t) => {
          t.text(FILE_ID_COLUMN).primary();
          t.text(REMOTE_ID_COLUMN).nullable().index();
          t.text(FOLDER_ID_COLUMN).index();
          t.text(PATH_COLUMN).unique();
          t.text(FOLDER_NAME_COLUMN);
          t.text(FILE_NAME_COLUMN);
          t.text(CONTENT_COLUMN).nullable();
          t.text(ORIGINAL_COLUMN).nullable();
          t.text(SUGGESTED_COLUMN).nullable();
          t.jsonb(METADATA_COLUMN).defaultTo('{}');
          t.timestamp(CREATED_AT_COLUMN, { useTz: false }).defaultTo(this.getKnex().fn.now());
          t.timestamp(UPDATED_AT_COLUMN, { useTz: false }).defaultTo(this.getKnex().fn.now());
          t.boolean(DELETED_COLUMN).defaultTo(false);
          t.boolean(SUGGESTED_DELETE_COLUMN).defaultTo(false);
          t.boolean(DIRTY_COLUMN).defaultTo(false);
          t.jsonb(ERRORS_COLUMN).defaultTo('{}');
          t.boolean(SEEN_COLUMN).defaultTo(false);
        });
    }
  }

  async listFilesAndFolders(workbookId: WorkbookId, parentFolderPath: string): Promise<FileDbRecord[]> {
    assertFolderPathIsValid(parentFolderPath);
    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(PATH_COLUMN, 'like', `${parentFolderPath}%`)
      .orderBy(PATH_COLUMN, 'asc')
      .select('*');

    return result;
  }

  /**
   * Returns a single FileDbRecord for a unique ID
   */
  async getFileById(workbookId: WorkbookId, fileId: FileId): Promise<FileDbRecord | null> {
    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(FILE_ID_COLUMN, fileId)
      .select('*')
      .first();

    return result ?? null;
  }

  /**
   * Finds a file using its full path
   * @param workbookId - The workbook ID
   * @param fullPath - The full path of the file
   * @returns The FileDbRecord if found, otherwise null
   */
  async getFileByPath(workbookId: WorkbookId, fullPath: string): Promise<FileDbRecord | null> {
    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(PATH_COLUMN, fullPath)
      .select('*')
      .first();

    return result ?? null;
  }

  /**
   * Returns FileDbRecords for a list of file IDs
   */
  async getFilesByIds(workbookId: WorkbookId, fileIds: FileId[]): Promise<FileDbRecord[]> {
    if (fileIds.length === 0) {
      return [];
    }

    const results = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .whereIn(FILE_ID_COLUMN, fileIds)
      .select('*');

    return results;
  }

  /**
   * Accepts suggestions for a file by path
   * Copies the suggested column value to content, sets suggested to null, and updates the timestamp
   * Only updates files where suggested is not null
   */
  async acceptSuggestionByPath(workbookId: WorkbookId, filePath: string): Promise<number> {
    assertFilePathIsValid(filePath);

    const file = await this.getFileByPath(workbookId, filePath);

    if (!file) {
      throw new FileNotFoundError(filePath, workbookId);
    }

    if (file.suggested === null && file.suggested_delete === false) {
      return 0;
    }

    // check the suggested delete first
    if (file.suggested_delete === true) {
      // accept the suggestion and delete the file
      await this.deleteFileByPath(workbookId, filePath, true);
      return 1;
    }

    // this is an update operation, so we need to recalculate the metadata
    let metadata: Record<string, unknown> = {};

    if (file.suggested && file.suggested.length > 0) {
      try {
        const parsed = matter(file.suggested);
        metadata = parsed.data as Record<string, unknown>;
      } catch (error) {
        WSLogger.error({
          source: 'WorkbookDb',
          message: `Failed to parse suggested content as frontmatter`,
          stack: error instanceof Error ? error.stack : undefined,
        });
      }
    }

    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(PATH_COLUMN, filePath)
      .update({
        [CONTENT_COLUMN]: this.getKnex().raw('??', [SUGGESTED_COLUMN]),
        [SUGGESTED_COLUMN]: null,
        [METADATA_COLUMN]: metadata,
        [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
        [DIRTY_COLUMN]: true,
      });

    return result ?? 0;
  }

  /**
   * Rejects suggestions for a file by path
   * Sets the suggested column to null and clears the suggested_delete flag without updating content
   * Only updates files where suggested is not null
   */
  async rejectSuggestionByPath(workbookId: WorkbookId, filePath: string): Promise<number> {
    assertFilePathIsValid(filePath);
    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(PATH_COLUMN, filePath)
      .whereNotNull(SUGGESTED_COLUMN)
      .update({
        [SUGGESTED_COLUMN]: null,
        [SUGGESTED_DELETE_COLUMN]: false,
      });

    return result;
  }

  /**
   * Accepts suggestions for all files in a folder
   * Copies the suggested column value to content, sets suggested to null, and updates the timestamp
   * Only updates files where suggested is not null
   */
  async acceptSuggestionsForFolder(workbookId: WorkbookId, folderPath: string): Promise<number> {
    assertFolderPathIsValid(folderPath);
    // TODO: this needs to to be rewriten to handle suggestions one at a time, inside of a transaction in order
    // to handle the deletes, updates and metadata recalculations properly

    const folderId = extractFolderId(folderPath);
    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(FOLDER_ID_COLUMN, folderId)
      .whereNotNull(SUGGESTED_COLUMN)
      .update({
        [CONTENT_COLUMN]: this.getKnex().raw('??', [SUGGESTED_COLUMN]),
        [SUGGESTED_COLUMN]: null,
        [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
      });

    return result;
  }

  /**
   * Rejects suggestions for all files in a folder
   * Sets the suggested column to null and clears the suggested_delete flag without updating content
   * Only updates files where suggested is not null
   */
  async rejectSuggestionsForFolder(workbookId: WorkbookId, folderPath: string): Promise<number> {
    const folderId = extractFolderId(folderPath);
    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(FOLDER_ID_COLUMN, folderId)
      .whereNotNull(SUGGESTED_COLUMN)
      .update({
        [SUGGESTED_COLUMN]: null,
        [SUGGESTED_DELETE_COLUMN]: false,
      });

    return result;
  }

  /**
   * Creates a new file in the database
   */
  async createFile(
    workbookId: WorkbookId,
    folderPath: string, // a list of folder ids with the last element being the folder that owns the file
    fileName: string, // the name of the file
    content: string | null,
    isSuggestion: boolean,
  ): Promise<FileDbRecord> {
    assertFolderPathIsValid(folderPath);

    const fileId = createFileId();
    const tempRemoteId = `${UNPUBLISHED_PREFIX}${fileId}`;

    // Generate the path
    const folderId = extractFolderId(folderPath);
    const fullPath = path.posix.join(folderPath, fileName);

    if (isSuggestion) {
      return await this.getKnex()<FileDbRecord>(FILES_TABLE)
        .withSchema(workbookId)
        .insert({
          [FILE_ID_COLUMN]: fileId,
          [REMOTE_ID_COLUMN]: tempRemoteId,
          [FOLDER_ID_COLUMN]: folderId,
          [PATH_COLUMN]: fullPath,
          [FOLDER_NAME_COLUMN]: folderId,
          [FILE_NAME_COLUMN]: fileName,
          [CONTENT_COLUMN]: null,
          [ORIGINAL_COLUMN]: null,
          [SUGGESTED_COLUMN]: content,
          [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
          [CREATED_AT_COLUMN]: this.getKnex().fn.now(),
        });
    } else {
      let metadata: Record<string, unknown> = {};
      if (content) {
        try {
          const parsed = matter(content);
          metadata = parsed.data as Record<string, unknown>;
        } catch (error) {
          WSLogger.error({
            source: 'WorkbookDb',
            message: `Failed to parse content as frontmatter`,
            stack: error instanceof Error ? error.stack : undefined,
          });
        }
      }

      return await this.getKnex()<FileDbRecord>(FILES_TABLE)
        .withSchema(workbookId)
        .insert({
          [FILE_ID_COLUMN]: fileId,
          [REMOTE_ID_COLUMN]: tempRemoteId,
          [FOLDER_ID_COLUMN]: folderId,
          [PATH_COLUMN]: fullPath,
          [FOLDER_NAME_COLUMN]: folderId,
          [FILE_NAME_COLUMN]: fileName,
          [CONTENT_COLUMN]: content,
          [ORIGINAL_COLUMN]: null,
          [SUGGESTED_COLUMN]: null,
          [METADATA_COLUMN]: metadata,
          [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
          [CREATED_AT_COLUMN]: this.getKnex().fn.now(),
          [DIRTY_COLUMN]: true,
        });
    }
  }

  /**
   * Deletes a file from the database
   * If the file is a suggestion, sets the suggested column to empty string and sets the suggested_delete flag
   * If the file is not a suggestion, checks if the record has original content, if so flags it for deletion, otherwise deletes from table
   */
  async deleteFileById(workbookId: WorkbookId, fileId: FileId, isSuggestion: boolean): Promise<void> {
    if (isSuggestion) {
      // Suggested delete: set suggested column to empty string and set suggested_delete flag
      await this.getKnex()<FileDbRecord>(FILES_TABLE)
        .withSchema(workbookId)
        .where(FILE_ID_COLUMN, fileId)
        .update({
          [SUGGESTED_COLUMN]: '',
          [SUGGESTED_DELETE_COLUMN]: true,
          [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
        });
    } else {
      const record = await this.getKnex()<FileDbRecord>(FILES_TABLE)
        .withSchema(workbookId)
        .where(FILE_ID_COLUMN, fileId)
        .first<{ [ORIGINAL_COLUMN]: string | null }>();

      if (record?.[ORIGINAL_COLUMN] !== null) {
        // Record has original content, flag it for deletion instead of hard deleting
        await this.getKnex()<FileDbRecord>(FILES_TABLE)
          .withSchema(workbookId)
          .where(FILE_ID_COLUMN, fileId)
          .update({
            [DELETED_COLUMN]: true,
            [DIRTY_COLUMN]: true,
            [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
          });
      } else {
        // No original content, harddelete from table
        await this.getKnex()<FileDbRecord>(FILES_TABLE).withSchema(workbookId).where(FILE_ID_COLUMN, fileId).delete();
      }
    }
  }

  /**
   * Clears the delete flag on a file
   */
  async undeleteFileByPath(workbookId: WorkbookId, filePath: string): Promise<void> {
    assertFilePathIsValid(filePath);
    await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(PATH_COLUMN, filePath)
      .update({
        [DELETED_COLUMN]: false,
      });
  }

  async createFileByPath(
    workbookId: WorkbookId,
    fullPath: string,
    content: string | null,
    isSuggestion: boolean = false,
  ): Promise<string> {
    assertFilePathIsValid(fullPath);
    const folderPath = extractFolderPath(fullPath);
    const fileName = extractFileName(fullPath);

    if (!fileName) {
      throw new Error(`No filename found on path: ${fullPath}`);
    }
    const newFile = await this.createFile(workbookId, folderPath, fileName, content, isSuggestion);
    return newFile.path;
  }

  async moveFile(
    workbookId: WorkbookId,

    filePath: FileId,

    newPath: string,
  ): Promise<void> {
    assertFilePathIsValid(filePath);
    assertFilePathIsValid(newPath);
    const file = await this.getFileByPath(workbookId, filePath);
    if (!file) {
      throw new FileNotFoundError(filePath, workbookId);
    }
    // update the path of the file and potentially the name
    // TODO: implement this
  }

  async copyFile(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    workbookId: WorkbookId,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    filePath: FileId,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    newPath: string,
  ): Promise<void> {
    // TODO: this should create a new file with the same content and metadata
    // TODO: implement this
  }

  async updateFileByPath(
    workbookId: WorkbookId,
    currentPath: string,
    updates: {
      newPath?: string; // If provided, rename/move the file
      content?: string | null;
    },
  ): Promise<void> {
    const file = await this.getFileByPath(workbookId, currentPath);
    if (!file) {
      throw new FileNotFoundError(currentPath, workbookId);
    }

    await this.updateFile(workbookId, file.id as FileId, updates.content ?? null, false);
  }

  async deleteFileByPath(workbookId: WorkbookId, filePath: string, isSuggestion: boolean = false): Promise<void> {
    const file = await this.getFileByPath(workbookId, filePath);

    if (!file) {
      throw new FileNotFoundError(filePath, workbookId);
    }

    await this.deleteFileById(workbookId, file.id as FileId, isSuggestion);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async renameFolder(workbookId: WorkbookId, oldFolderPath: string, newFolderPath: string): Promise<number> {
    // TODO: This is actually pretty complex and just handles the files side of things.  The SnapshotTable path also needs to be updated
    // For each file on the path we need to update:
    // - the path column
    // If the folder a file belongs to is changes, need to update these as well:
    // - the folder_id column
    // - the folder_name column

    throw new Error('Not yet implemented');
  }

  /**
   * Updates the content of a file
   */
  async updateFile(
    workbookId: WorkbookId,
    fileId: FileId,
    content: string | null,
    isSuggestion: boolean,
  ): Promise<void> {
    if (isSuggestion) {
      await this.getKnex()<FileDbRecord>(FILES_TABLE)
        .withSchema(workbookId)
        .where(FILE_ID_COLUMN, fileId)
        .update({
          [SUGGESTED_COLUMN]: content,
          [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
        });
    } else {
      // Parse the content into a frontmatter object and extract the metadata to save to the database
      let metadata: Record<string, unknown> = {};

      if (content) {
        try {
          const parsed = matter(content);
          metadata = parsed.data as Record<string, unknown>;
        } catch (error) {
          WSLogger.error({
            source: 'WorkbookDb',
            message: `Failed to parse content as frontmatter`,
            stack: error instanceof Error ? error.stack : undefined,
          });

          // If parsing fails, just use empty metadata
          metadata = {};
        }
      }

      await this.getKnex()<FileDbRecord>(FILES_TABLE)
        .withSchema(workbookId)
        .where(FILE_ID_COLUMN, fileId)
        .update({
          [CONTENT_COLUMN]: content,
          [METADATA_COLUMN]: metadata,
          [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
          [DIRTY_COLUMN]: true,
        });
    }
  }

  /**
   * Deletes all of the files related to a specific folder
   */
  async deleteFolderContents(workbookId: WorkbookId, folderPath: string): Promise<void> {
    const folderId = extractFolderId(folderPath);

    // NOTE: this should probably be done in batches with a progress callback
    await this.getKnex()<FileDbRecord>(FILES_TABLE).withSchema(workbookId).where(FOLDER_ID_COLUMN, folderId).delete();
  }

  /**
   * Upserts files from an array of ConnectorRecord objects.
   * Converts each ConnectorRecord to Front Matter markdown format.
   * The main content body is extracted from the field specified by mainContentColumnRemoteId in the TableSpec.
   * All other fields are stored as metadata in the YAML front matter.
   *
   * @param workbookId - The workbook ID
   * @param folderId - The folder ID where files will be stored
   * @param records - Array of ConnectorRecord objects to upsert
   * @param tableSpec - TableSpec containing column definitions and mainContentColumnRemoteId
   * @returns Promise that resolves when all files have been upserted
   */
  async upsertFilesFromConnectorRecords<T extends BaseColumnSpec>(
    workbookId: WorkbookId,
    folderPath: string,
    records: ConnectorRecord[],
    tableSpec: BaseTableSpec<T>,
  ): Promise<void> {
    assertFolderPathIsValid(folderPath);

    await this.getKnex().transaction(async (trx) => {
      for (const record of records) {
        // Convert to Front Matter markdown format
        const { content: frontMatterContent, metadata: frontMatterMetadata } = convertConnectorRecordToFrontMatter(
          record,
          tableSpec,
        );

        // Generate a scratch ID for new records
        const fileId = createFileId();

        const folderId = extractFolderId(folderPath);
        const folderName = folderId;

        // Determine the file name - use title column if available, otherwise use the record ID
        let fileName = record.id;
        let fullPath = path.posix.join(folderPath, fileName);
        let attempts = 0;
        while (attempts < MAX_UNIQUE_FILE_NAME_ATTEMPTS) {
          if (tableSpec.titleColumnRemoteId) {
            const column = tableSpec.columns.find((c) => _.isEqual(c.id.remoteId, tableSpec.titleColumnRemoteId));
            const titleValue = record.fields[column?.id.wsId ?? ''];
            if (titleValue && typeof titleValue === 'string') {
              fileName = titleValue;
            }
          }

          if (attempts > 0) {
            fileName = slugifyFileName(fileName) + '-' + attempts + '.md';
          }

          fileName = slugifyFileName(fileName) + '.md';
          fullPath = folderPath + '/' + fileName;

          const existingFileWithPath = await trx<FileDbRecord>(FILES_TABLE)
            .withSchema(workbookId)
            .where(PATH_COLUMN, fullPath)
            .first();

          if (!existingFileWithPath) {
            break;
          }
          attempts++;
        }

        if (attempts >= MAX_UNIQUE_FILE_NAME_ATTEMPTS) {
          throw new Error(
            `Failed to generate a unique file name for record ${record.id} after 20 attempts: ${fullPath}`,
          );
        }

        // Check if file with this remote_id already exists
        const existingFile = await trx<FileDbRecord>(FILES_TABLE)
          .withSchema(workbookId)
          .where(REMOTE_ID_COLUMN, record.id)
          .where(FOLDER_ID_COLUMN, folderId)
          .first();

        if (existingFile) {
          // Update existing file
          await trx(FILES_TABLE)
            .withSchema(workbookId)
            .where(FILE_ID_COLUMN, existingFile[FILE_ID_COLUMN])
            .update({
              [ORIGINAL_COLUMN]: frontMatterContent, // this resets the original content new value from the connector
              [CONTENT_COLUMN]: frontMatterContent,
              [METADATA_COLUMN]: frontMatterMetadata,
              [DIRTY_COLUMN]: false, // Reset dirty flag since content matches remote
              [ERRORS_COLUMN]: record.errors || {},
              [UPDATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
            });
        } else {
          // Insert new file
          await trx(FILES_TABLE)
            .withSchema(workbookId)
            .insert({
              [FILE_ID_COLUMN]: fileId,
              [REMOTE_ID_COLUMN]: record.id,
              [FOLDER_ID_COLUMN]: folderId,
              [FOLDER_NAME_COLUMN]: folderName,
              [FILE_NAME_COLUMN]: fileName,
              [PATH_COLUMN]: fullPath,
              [CONTENT_COLUMN]: frontMatterContent,
              [ORIGINAL_COLUMN]: frontMatterContent,
              [SUGGESTED_COLUMN]: null,
              [METADATA_COLUMN]: frontMatterMetadata,
              [CREATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
              [UPDATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
              [DELETED_COLUMN]: false,
              [DIRTY_COLUMN]: false, // New files from connector are clean
              [ERRORS_COLUMN]: record.errors || {},
            });
        }
      }
    });
  }

  async resetSeenFlagForFolder(workbookId: WorkbookId, folderPath: string): Promise<void> {
    const folderId = extractFolderId(folderPath);
    await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(FOLDER_ID_COLUMN, folderId)
      .update({ [SEEN_COLUMN]: false });
  }

  public getKnex(): Knex {
    if (!this.knex) {
      throw new Error('Expected knex to not be undefined');
    }
    return this.knex;
  }
}

/* * * * * * * * * * * * * * * * * * * * * * * *
 *
 * Utility functions
 *
 * * * * * * * * * * * * * * * * * * * * * * * */

/**
 * Converts a ConnectorRecord to Front Matter markdown format.
 * The main content body is extracted from the field specified by mainContentColumnRemoteId in the TableSpec.
 * All other fields are stored as metadata in the YAML front matter.
 *
 * @param record - The ConnectorRecord to convert
 * @param tableSpec - TableSpec containing column definitions and mainContentColumnRemoteId
 * @returns Front Matter markdown string
 */
export function convertConnectorRecordToFrontMatter<T extends BaseColumnSpec>(
  record: ConnectorRecord,
  tableSpec: BaseTableSpec<T>,
): { content: string; metadata: Record<string, unknown> } {
  // Determine the main content column key
  let mainContentKey: string | undefined;
  if (tableSpec.mainContentColumnRemoteId) {
    // this is likely incorrect - need to handle the string array case
    mainContentKey = tableSpec.mainContentColumnRemoteId[0];
  }

  // Extract main content and metadata from record fields
  let bodyContent = '';
  const metadata: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(record.fields)) {
    if (mainContentKey && key === mainContentKey) {
      // This is the main content field
      bodyContent =
        typeof value === 'string' ? value : value === null || value === undefined ? '' : JSON.stringify(value, null, 2);
    } else {
      // All other fields go to metadata
      metadata[key] = value;
    }
  }

  // Convert to Front Matter markdown format
  return { content: matter.stringify(bodyContent, metadata), metadata };
}

export function slugifyFileName(text: string): string {
  return text
    .toString() // Ensure the input is a string
    .normalize('NFD') // Split accented letters into base letter and accent
    .replace(/[\u0300-\u036f]/g, '') // Remove all previously split accents (diacritical marks)
    .toLowerCase() // Convert to lowercase
    .trim() // Trim leading/trailing whitespace
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/[^a-z0-9 -]/g, '') // Remove all non-alphanumeric characters, except hyphens and spaces
    .replace(/-+/g, '-'); // Replace multiple hyphens with a single hyphen
}

/**
 * Extracts the folder ID from a file path. Currently this is the last folder in the path
 * @param filePath - The file path to extract the folder ID from
 * @returns The folder ID
 */
export function extractFolderId(filePath: string): SnapshotTableId {
  const { dir, base, ext } = path.posix.parse(filePath);

  if (!ext || ext === '') {
    // this is a folder path, with no file at the end
    // the base will be the last part of the path, which is the folder name
    return base as SnapshotTableId;
  }

  // this is a file path, so we need to parse the folder from the dir
  const directoryParts = dir.split('/');
  return directoryParts[directoryParts.length - 1] as SnapshotTableId;
}

/**
 * Extracts the folder path from a file path, removing the file name and extension
 * @param filePath - The file path to extract the folder path from
 * @returns The folder path
 */
export function extractFolderPath(filePath: string): string {
  const { dir, base, ext } = path.posix.parse(filePath);

  if (!ext || ext === '') {
    // this is a folder path, with no file at the end
    // the base will be the last part of the path, which is a directory and we need to add it back to the dir
    return path.posix.join(dir, base);
  }

  // the end of the path is a file, so the whole `dir` value is the folder path
  return dir;
}

/**
 * Extracts the file name from a file path, including the extension
 * @param filePath - The file path to extract the file name from
 * @returns The file name including the extension or an empty string if there is no file on this path
 */
export function extractFileName(filePath: string): string {
  const { base, ext } = path.posix.parse(filePath);
  if (!ext || ext === '') {
    return '';
  }
  return base;
}

function assertFolderPathIsValid(path: unknown): asserts path is string {
  if (typeof path !== 'string') {
    throw new Error(`Path must be a string, but got ${typeof path}: ${path as string}`);
  }
  if (path.length === 0) {
    throw new Error('Path must not be empty');
  }
  if (!path.startsWith('/')) {
    throw new Error('Path must start with a slash');
  }
}

function assertFilePathIsValid(path: unknown): asserts path is string {
  if (typeof path !== 'string') {
    throw new Error(`Path must be a string, but got ${typeof path}: ${path as string}`);
  }
  if (path.length === 0) {
    throw new Error('Path must not be empty');
  }
  if (!path.startsWith('/')) {
    throw new Error('Path must start with a slash');
  }

  const file = extractFileName(path);
  if (!file || file.length === 0) {
    throw new Error('Path must contain a file name');
  }
}

export class FileNotFoundError extends Error {
  public readonly filePath: string;
  public readonly workbookId: WorkbookId;

  constructor(filePath: string, workbookId: WorkbookId, cause?: Error) {
    super(`File not found: ${filePath} in workbook ${workbookId}`, { cause });
    this.name = 'FileNotFoundError';
    this.filePath = filePath;
    this.workbookId = workbookId;
  }
}
