/* eslint-disable @typescript-eslint/require-await */
import {
  createFileId,
  FileId,
  SnapshotRecordId,
  SnapshotTableId,
  UNPUBLISHED_PREFIX,
  WorkbookId,
} from '@spinner/shared-types';
import matter from 'gray-matter';
import { Knex } from 'knex';
import _ from 'lodash';
import {
  BaseColumnSpec,
  BaseTableSpec,
  ConnectorRecord,
  RecordErrorsMetadata,
  SnapshotRecord,
} from '../remote-service/connectors/types';

// Table name constant
export const FILES_TABLE = 'files';

// Column name constants for the files table

// The internal unique identifier for the file
export const SCRATCH_ID_COLUMN = 'id';

// The remote identifier for the file if linked to a remote source
export const REMOTE_ID_COLUMN = 'remote_id';

// The folder the file belongs to, used to perform folder-scoped operations on files without needind to string-match the path
export const FOLDER_ID_COLUMN = 'folder_id';

// The full path of the file in the folder hierarchy including all of the folders and ending with the file name
export const PATH_COLUMN = 'path';

// A generated value based on the path, providing the name of the folder this file belongs to.
// Until we implement folder slugs, this will be the same as the folder_id
// NOTE: this might be redundant give we could pull the value from the path column instead
export const FOLDER_NAME_COLUMN = 'folder';

// A generated value based on the path, providing the name of the file
// File name is managed by scratch though the initial value may be sourced from a title or name field in the connector record
export const FILE_NAME_COLUMN = 'name';

// The active content of the file, as it appears in the UI
export const CONTENT_COLUMN = 'content';

// The original content of the file, as it was when it was first created or pulled from the remote source.
export const ORIGINAL_COLUMN = 'original';

// The suggested content of the file, as generated by the agent
export const SUGGESTED_COLUMN = 'suggested';

// The flag indicating that the file was deleted by the agent and is pending acceptance by the user
export const SUGGESTED_DELETE_COLUMN = 'suggested_delete';

// Index of non-body Front Matter properties stored as key-value pairs. We can use JSON queries to create filters and sort
export const METADATA_COLUMN = 'metadata';

// The timestamp when the file was created
export const CREATED_AT_COLUMN = 'created_at';

// The timestamp when the file was last updated
export const UPDATED_AT_COLUMN = 'updated_at';

// The flag indicating that the file was deleted by the user and should get deleted from the remote source
export const DELETED_COLUMN = 'deleted';

// The flag indicating that the file has been modified since the original content was set
export const DIRTY_COLUMN = 'dirty';

// A JSON object containing connector-specific errors for the file
export const ERRORS_COLUMN = 'errors';

// tracks seen state for the file during sync operations
export const SEEN_COLUMN = 'seen';

export const FILE_PATH_PREFIX = '/';

/**
 * Different states of a file record
 * - new file (suggestion): suggested content <> null, original content === null
 * - new file (accepted): content <> null, original content === null
 * - deleted: deleted === true
 * - deleted (suggested): suggested_delete === true, suggested content <> null (i.e. set to '')
 * - modified: content <> original content
 * - pending change: suggested <> null && suggested <> content
 * - dirty: the file record has changed since the original content was set. Just a quick filter flag
 */

/**
 * Represents a single file record from the files table
 */
export type FileDbRecord = {
  [SCRATCH_ID_COLUMN]: string;
  [REMOTE_ID_COLUMN]: string | null;
  [FOLDER_ID_COLUMN]: string;
  [PATH_COLUMN]: string;
  [FOLDER_NAME_COLUMN]: string;
  [FILE_NAME_COLUMN]: string;
  [CONTENT_COLUMN]: string | null;
  [ORIGINAL_COLUMN]: string | null;
  [SUGGESTED_COLUMN]: string | null;
  [METADATA_COLUMN]: Record<string, unknown>;
  [CREATED_AT_COLUMN]: Date;
  [UPDATED_AT_COLUMN]: Date;
  [DELETED_COLUMN]: boolean;
  [SUGGESTED_DELETE_COLUMN]: boolean;
  [DIRTY_COLUMN]: boolean;
  [ERRORS_COLUMN]: Record<string, unknown>;
  [SEEN_COLUMN]: boolean;
};

export class WorkbookDb {
  public knex!: Knex;

  init(knex: Knex) {
    this.knex = knex;
  }

  /**
   * Creates a new schema for a workbook and creates the files table within it
   */
  async createForWorkbook(workbookId: WorkbookId) {
    // Create the schema if it doesn't exist
    await this.getKnex().raw(`CREATE SCHEMA IF NOT EXISTS "${workbookId}"`);

    // Check if the files table already exists
    const tableExists = await this.getKnex().schema.withSchema(workbookId).hasTable(FILES_TABLE);

    if (!tableExists) {
      // Create the central files table
      await this.getKnex()
        .schema.withSchema(workbookId)
        .createTable(FILES_TABLE, (t) => {
          t.text(SCRATCH_ID_COLUMN).primary();
          t.text(REMOTE_ID_COLUMN).nullable().index();
          t.text(FOLDER_ID_COLUMN).index();
          t.text(PATH_COLUMN).unique();
          t.text(FOLDER_NAME_COLUMN);
          t.text(FILE_NAME_COLUMN);
          t.text(CONTENT_COLUMN).nullable();
          t.text(ORIGINAL_COLUMN).nullable();
          t.text(SUGGESTED_COLUMN).nullable();
          t.jsonb(METADATA_COLUMN).defaultTo('{}');
          t.timestamp(CREATED_AT_COLUMN, { useTz: false }).defaultTo(this.getKnex().fn.now());
          t.timestamp(UPDATED_AT_COLUMN, { useTz: false }).defaultTo(this.getKnex().fn.now());
          t.boolean(DELETED_COLUMN).defaultTo(false);
          t.boolean(SUGGESTED_DELETE_COLUMN).defaultTo(false);
          t.boolean(DIRTY_COLUMN).defaultTo(false);
          t.jsonb(ERRORS_COLUMN).defaultTo('{}');
          t.boolean(SEEN_COLUMN).defaultTo(false);
        });
    }
  }

  /**
   * Returns all files for a specific folder
   */
  async listFiles(
    workbookId: WorkbookId,
    folderPath: string,
    skip: number,
    take: number,
    sqlFilter?: string | null,
  ): Promise<{ files: SnapshotRecord[]; count: number; filteredCount: number; skip: number; take: number }> {
    const folderId = getFolderIdFromPath(folderPath);
    const query = this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(FOLDER_ID_COLUMN, folderId)
      .orderBy(PATH_COLUMN, 'asc')
      .limit(take)
      .offset(skip);

    // Apply SQL filter if provided
    if (sqlFilter && sqlFilter.trim() !== '') {
      query.whereRaw(sqlFilter);
    }

    query.select('*');

    const result = await query;

    // Calculate counts
    let count: number;
    let filteredCount: number;

    if (sqlFilter && sqlFilter.trim() !== '') {
      // Count total files in folder without filter
      const totalQuery = this.getKnex()(FILES_TABLE).withSchema(workbookId).where(FOLDER_ID_COLUMN, folderId);
      const totalFiles = await totalQuery.count('* as count');
      count = parseInt(String(totalFiles[0].count), 10);

      // Count filtered files with filter
      const filteredQuery = this.getKnex()(FILES_TABLE).withSchema(workbookId).where(FOLDER_ID_COLUMN, folderId);
      filteredQuery.whereRaw(sqlFilter);
      const filteredFiles = await filteredQuery.count('* as count');
      filteredCount = parseInt(String(filteredFiles[0].count), 10);
    } else {
      // No filter, so both counts are the same
      const totalQuery = this.getKnex()(FILES_TABLE).withSchema(workbookId).where(FOLDER_ID_COLUMN, folderId);
      const totalFiles = await totalQuery.count('* as count');
      count = parseInt(String(totalFiles[0].count), 10);
      filteredCount = count;
    }

    const files = result.map((r) => convertFileDbRecordToSnapshotRecord(r));
    return {
      files,
      count,
      filteredCount,
      skip,
      take,
    };
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async listFilesAndFolders(workbookId: WorkbookId, parentFolderPath: string): Promise<FileDbRecord[]> {
    // TODO:
    throw new Error('Not yet implemented');
  }

  /**
   * Returns a single FileDbRecord for a unique ID
   */
  async getFileById(workbookId: WorkbookId, fileId: FileId): Promise<FileDbRecord | null> {
    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(SCRATCH_ID_COLUMN, fileId)
      .select('*')
      .first();

    return result ?? null;
  }

  /**
   * Finds a file using its full path
   * @param workbookId - The workbook ID
   * @param fullPath - The full path of the file
   * @returns The FileDbRecord if found, otherwise null
   */
  async getFileByPath(workbookId: WorkbookId, fullPath: string): Promise<FileDbRecord | null> {
    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(PATH_COLUMN, fullPath)
      .select('*')
      .first();

    return result ?? null;
  }

  /**
   * Returns FileDbRecords for a list of file IDs
   */
  async getFilesByIds(workbookId: WorkbookId, fileIds: FileId[]): Promise<FileDbRecord[]> {
    if (fileIds.length === 0) {
      return [];
    }

    const results = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .whereIn(SCRATCH_ID_COLUMN, fileIds)
      .select('*');

    return results;
  }

  /**
   * Accepts suggestions for a list of file IDs
   * Copies the suggested column value to content, sets suggested to null, and updates the timestamp
   * Only updates files where suggested is not null
   */
  async acceptSuggestions(workbookId: WorkbookId, fileIds: FileId[]): Promise<number> {
    if (fileIds.length === 0) {
      return 0;
    }

    // TODO: this needs to handle the suggested creates/deletes properly, setting the appropriate columns and timestamps

    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .whereIn(SCRATCH_ID_COLUMN, fileIds)
      .whereNotNull(SUGGESTED_COLUMN)
      .update({
        [CONTENT_COLUMN]: this.getKnex().raw('??', [SUGGESTED_COLUMN]),
        [SUGGESTED_COLUMN]: null,
        [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
      });

    return result;
  }

  /**
   * Rejects suggestions for a list of file IDs
   * Sets the suggested column to null and clears the suggested_delete flag without updating content
   * Only updates files where suggested is not null
   */
  async rejectSuggestions(workbookId: WorkbookId, fileIds: FileId[]): Promise<number> {
    if (fileIds.length === 0) {
      return 0;
    }

    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .whereIn(SCRATCH_ID_COLUMN, fileIds)
      .whereNotNull(SUGGESTED_COLUMN)
      .update({
        [SUGGESTED_COLUMN]: null,
        [SUGGESTED_DELETE_COLUMN]: false,
      });

    return result;
  }

  /**
   * Accepts suggestions for all files in a folder
   * Copies the suggested column value to content, sets suggested to null, and updates the timestamp
   * Only updates files where suggested is not null
   */
  async acceptSuggestionsForFolder(workbookId: WorkbookId, folderPath: string): Promise<number> {
    // TODO: this needs to handle the suggested creates/deletes properly, setting the appropriate columns and timestamps

    const folderId = getFolderIdFromPath(folderPath);
    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(FOLDER_ID_COLUMN, folderId)
      .whereNotNull(SUGGESTED_COLUMN)
      .update({
        [CONTENT_COLUMN]: this.getKnex().raw('??', [SUGGESTED_COLUMN]),
        [SUGGESTED_COLUMN]: null,
        [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
      });

    return result;
  }

  /**
   * Rejects suggestions for all files in a folder
   * Sets the suggested column to null and clears the suggested_delete flag without updating content
   * Only updates files where suggested is not null
   */
  async rejectSuggestionsForFolder(workbookId: WorkbookId, folderPath: string): Promise<number> {
    const folderId = getFolderIdFromPath(folderPath);
    const result = await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(FOLDER_ID_COLUMN, folderId)
      .whereNotNull(SUGGESTED_COLUMN)
      .update({
        [SUGGESTED_COLUMN]: null,
        [SUGGESTED_DELETE_COLUMN]: false,
      });

    return result;
  }

  /**
   * Creates a new file in the database
   */
  async createFile(
    workbookId: WorkbookId,
    folderPath: string, // a list of folder ids with the last element being the folder that owns the file
    fileName: string, // the name of the file
    content: string,
    isSuggestion: boolean,
  ): Promise<void> {
    assertPathIsValid(folderPath);

    const scratchId = createFileId();
    const tempRemoteId = `${UNPUBLISHED_PREFIX}${scratchId}`;

    // Generate the path
    const folderId = getFolderIdFromPath(folderPath);
    const fullPath = folderPath + '/' + fileName;

    if (isSuggestion) {
      await this.getKnex()<FileDbRecord>(FILES_TABLE)
        .withSchema(workbookId)
        .insert({
          [SCRATCH_ID_COLUMN]: scratchId,
          [REMOTE_ID_COLUMN]: tempRemoteId,
          [FOLDER_ID_COLUMN]: folderId,
          [PATH_COLUMN]: fullPath,
          [FOLDER_NAME_COLUMN]: folderId,
          [FILE_NAME_COLUMN]: fileName,
          [CONTENT_COLUMN]: null,
          [ORIGINAL_COLUMN]: null,
          [SUGGESTED_COLUMN]: content,
          [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
          [CREATED_AT_COLUMN]: this.getKnex().fn.now(),
        });
    } else {
      await this.getKnex()<FileDbRecord>(FILES_TABLE)
        .withSchema(workbookId)
        .insert({
          [SCRATCH_ID_COLUMN]: scratchId,
          [REMOTE_ID_COLUMN]: tempRemoteId,
          [FOLDER_ID_COLUMN]: folderId,
          [PATH_COLUMN]: fullPath,
          [FOLDER_NAME_COLUMN]: folderId,
          [FILE_NAME_COLUMN]: fileName,
          [CONTENT_COLUMN]: content,
          [ORIGINAL_COLUMN]: null,
          [SUGGESTED_COLUMN]: null,
          [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
          [CREATED_AT_COLUMN]: this.getKnex().fn.now(),
          [DIRTY_COLUMN]: true,
        });
    }
  }

  /**
   * Deletes a file from the database
   * If the file is a suggestion, sets the suggested column to empty string and sets the suggested_delete flag
   * If the file is not a suggestion, checks if the record has original content, if so flags it for deletion, otherwise deletes from table
   */
  async deleteFile(workbookId: WorkbookId, fileId: FileId, isSuggestion: boolean): Promise<void> {
    if (isSuggestion) {
      // Suggested delete: set suggested column to empty string and set suggested_delete flag
      await this.getKnex()<FileDbRecord>(FILES_TABLE)
        .withSchema(workbookId)
        .where(SCRATCH_ID_COLUMN, fileId)
        .update({
          [SUGGESTED_COLUMN]: '',
          [SUGGESTED_DELETE_COLUMN]: true,
          [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
        });
    } else {
      const record = await this.getKnex()<FileDbRecord>(FILES_TABLE)
        .withSchema(workbookId)
        .where(SCRATCH_ID_COLUMN, fileId)
        .first<{ [ORIGINAL_COLUMN]: string | null }>();

      if (record?.[ORIGINAL_COLUMN] !== null) {
        // Record has original content, flag it for deletion
        await this.getKnex()<FileDbRecord>(FILES_TABLE)
          .withSchema(workbookId)
          .where(SCRATCH_ID_COLUMN, fileId)
          .update({
            [DELETED_COLUMN]: true,
            [DIRTY_COLUMN]: true,
            [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
          });
      } else {
        // No original content, delete from table
        await this.getKnex()<FileDbRecord>(FILES_TABLE)
          .withSchema(workbookId)
          .where(SCRATCH_ID_COLUMN, fileId)
          .delete();
      }
    }
  }

  /**
   * Undeletes a file from the database. This only works for files that have been deleted by the user and does not support suggested deletes.
   * @param workbookId - The workbook ID
   * @param fileId - The file ID
   * @returns Promise that resolves when the file has been undeleted
   */
  async undeleteFile(workbookId: WorkbookId, fileId: FileId): Promise<void> {
    await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(SCRATCH_ID_COLUMN, fileId)
      .update({
        [DELETED_COLUMN]: false,
      });
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async createFileByPath(workbookId: WorkbookId, fullPath: string, content: string | null): Promise<string> {
    // TODO:
    throw new Error('Not yet implemented');
  }

  async updateFileByPath(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    workbookId: WorkbookId,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    currentPath: string,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updates: {
      newPath?: string; // If provided, rename/move the file
      content?: string | null;
    },
  ): Promise<void> {
    // TODO:
    throw new Error('Not yet implemented');
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async deleteFileByPath(workbookId: WorkbookId, filePath: string): Promise<void> {
    // TODO:
    throw new Error('Not yet implemented');
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async renameFolder(workbookId: WorkbookId, oldFolderPath: string, newFolderPath: string): Promise<number> {
    // TODO:
    throw new Error('Not yet implemented');
  }

  /**
   * Bulk update files with create, update, delete, and undelete operations
   * The data in RecordOperation will have a single property named 'content'
   */
  async bulkUpdateFiles(workbookId: WorkbookId, fileId: FileId, content: string, isSuggestion: boolean): Promise<void> {
    if (isSuggestion) {
      await this.getKnex()<FileDbRecord>(FILES_TABLE)
        .withSchema(workbookId)
        .where(SCRATCH_ID_COLUMN, fileId)
        .update({
          [SUGGESTED_COLUMN]: content,
          [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
        });
    } else {
      // TODO : parse the content into a frontmatter object and extract the metadata to save to the database

      await this.getKnex()<FileDbRecord>(FILES_TABLE)
        .withSchema(workbookId)
        .where(SCRATCH_ID_COLUMN, fileId)
        .update({
          [CONTENT_COLUMN]: content,
          [UPDATED_AT_COLUMN]: this.getKnex().fn.now(),
          [DIRTY_COLUMN]: true,
        });
    }
  }

  /**
   * Deletes all of the files related to a specific folder
   */
  async deleteFolderContents(workbookId: WorkbookId, folderPath: string): Promise<void> {
    const folderId = getFolderIdFromPath(folderPath);
    await this.getKnex()<FileDbRecord>(FILES_TABLE).withSchema(workbookId).where(FOLDER_ID_COLUMN, folderId).delete();
  }

  /**
   * Upserts files from an array of ConnectorRecord objects.
   * Converts each ConnectorRecord to Front Matter markdown format.
   * The main content body is extracted from the field specified by mainContentColumnRemoteId in the TableSpec.
   * All other fields are stored as metadata in the YAML front matter.
   *
   * @param workbookId - The workbook ID
   * @param folderId - The folder ID where files will be stored
   * @param records - Array of ConnectorRecord objects to upsert
   * @param tableSpec - TableSpec containing column definitions and mainContentColumnRemoteId
   * @returns Promise that resolves when all files have been upserted
   */
  async upsertFilesFromConnectorRecords<T extends BaseColumnSpec>(
    workbookId: WorkbookId,
    folderPath: string,
    records: ConnectorRecord[],
    tableSpec: BaseTableSpec<T>,
  ): Promise<void> {
    assertPathIsValid(folderPath);

    await this.getKnex().transaction(async (trx) => {
      for (const record of records) {
        // Convert to Front Matter markdown format
        const { content: frontMatterContent, metadata: frontMatterMetadata } = convertConnectorRecordToFrontMatter(
          record,
          tableSpec,
        );

        // Generate a scratch ID for new records
        const scratchId = createFileId();

        // Determine the file name - use title column if available, otherwise use the record ID
        let fileName = record.id;

        if (tableSpec.titleColumnRemoteId) {
          const column = tableSpec.columns.find((c) => _.isEqual(c.id.remoteId, tableSpec.titleColumnRemoteId));
          const titleValue = record.fields[column?.id.wsId ?? ''];
          if (titleValue && typeof titleValue === 'string') {
            fileName = titleValue;
          }
        }

        fileName = slugifyFileName(fileName) + '.md';

        const folderId = getFolderIdFromPath(folderPath);
        const folderName = folderId;
        const fullPath = folderPath + '/' + fileName;

        // Check if file with this remote_id already exists
        const existingFile = await trx<FileDbRecord>(FILES_TABLE)
          .withSchema(workbookId)
          .where(REMOTE_ID_COLUMN, record.id)
          .where(FOLDER_ID_COLUMN, folderId)
          .first();

        if (existingFile) {
          // Update existing file
          await trx(FILES_TABLE)
            .withSchema(workbookId)
            .where(SCRATCH_ID_COLUMN, existingFile[SCRATCH_ID_COLUMN])
            .update({
              [ORIGINAL_COLUMN]: frontMatterContent, // this resets the original content new value from the connector
              [CONTENT_COLUMN]: frontMatterContent,
              [METADATA_COLUMN]: frontMatterMetadata,
              [DIRTY_COLUMN]: false, // Reset dirty flag since content matches remote
              [ERRORS_COLUMN]: record.errors || {},
              [UPDATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
            });
        } else {
          // Insert new file
          await trx(FILES_TABLE)
            .withSchema(workbookId)
            .insert({
              [SCRATCH_ID_COLUMN]: scratchId,
              [REMOTE_ID_COLUMN]: record.id,
              [FOLDER_ID_COLUMN]: folderId,
              [FOLDER_NAME_COLUMN]: folderName,
              [FILE_NAME_COLUMN]: fileName,
              [PATH_COLUMN]: fullPath,
              [CONTENT_COLUMN]: frontMatterContent,
              [ORIGINAL_COLUMN]: frontMatterContent,
              [SUGGESTED_COLUMN]: null,
              [METADATA_COLUMN]: frontMatterMetadata,
              [CREATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
              [UPDATED_AT_COLUMN]: trx.raw('CURRENT_TIMESTAMP'),
              [DELETED_COLUMN]: false,
              [DIRTY_COLUMN]: false, // New files from connector are clean
              [ERRORS_COLUMN]: record.errors || {},
            });
        }
      }
    });
  }

  async resetSeenFlagForFolder(workbookId: WorkbookId, folderPath: string): Promise<void> {
    const folderId = getFolderIdFromPath(folderPath);
    await this.getKnex()<FileDbRecord>(FILES_TABLE)
      .withSchema(workbookId)
      .where(FOLDER_ID_COLUMN, folderId)
      .update({ [SEEN_COLUMN]: false });
  }

  public getKnex(): Knex {
    if (!this.knex) {
      throw new Error('Expected knex to not be undefined');
    }
    return this.knex;
  }
}

/************************
 *
 * Utility functions
 *
 * *************************/

/**
 * Converts a ConnectorRecord to Front Matter markdown format.
 * The main content body is extracted from the field specified by mainContentColumnRemoteId in the TableSpec.
 * All other fields are stored as metadata in the YAML front matter.
 *
 * @param record - The ConnectorRecord to convert
 * @param tableSpec - TableSpec containing column definitions and mainContentColumnRemoteId
 * @returns Front Matter markdown string
 */
export function convertConnectorRecordToFrontMatter<T extends BaseColumnSpec>(
  record: ConnectorRecord,
  tableSpec: BaseTableSpec<T>,
): { content: string; metadata: Record<string, unknown> } {
  // Determine the main content column key
  let mainContentKey: string | undefined;
  if (tableSpec.mainContentColumnRemoteId) {
    // this is likely incorrect - need to handle the string array case
    mainContentKey = tableSpec.mainContentColumnRemoteId[0];
  }

  // Extract main content and metadata from record fields
  let bodyContent = '';
  const metadata: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(record.fields)) {
    if (mainContentKey && key === mainContentKey) {
      // This is the main content field
      bodyContent =
        typeof value === 'string' ? value : value === null || value === undefined ? '' : JSON.stringify(value, null, 2);
    } else {
      // All other fields go to metadata
      metadata[key] = value;
    }
  }

  // Convert to Front Matter markdown format
  return { content: matter.stringify(bodyContent, metadata), metadata };
}

/**
 * Updates a metadata field in frontmatter content.
 *
 * @param frontmatterContent - The current frontmatter markdown content
 * @param fieldName - The name of the metadata field to update
 * @param newValue - The new value for the field
 * @returns Updated frontmatter markdown string
 */
export function updateFrontmatterMetadata(
  frontmatterContent: string | null,
  fieldName: string,
  newValue: unknown,
): string {
  if (!frontmatterContent) {
    // If no content, create new frontmatter with just the field
    return matter.stringify('', { [fieldName]: newValue });
  }

  // Parse existing frontmatter
  const parsed = matter(frontmatterContent);
  const metadata = parsed.data as Record<string, unknown>;

  // Update the specific field
  metadata[fieldName] = newValue;

  // Reconstruct frontmatter
  return matter.stringify(parsed.content, metadata);
}

/**
 * Converts a FileDbRecord into a SnapshotRecord.
 * The content column value is mapped to a single property in the fields object.
 * If the suggested column is not null, it is included in __suggested_values.
 *
 * @param fileRecord - The FileDbRecord to convert
 * @returns A SnapshotRecord
 */
export function convertFileDbRecordToSnapshotRecord(fileRecord: FileDbRecord): SnapshotRecord {
  const fields: Record<string, unknown> = { content: fileRecord[CONTENT_COLUMN] };
  const suggestedValues: Record<string, unknown> = { content: fileRecord[SUGGESTED_COLUMN] ?? undefined };
  if (fileRecord[SUGGESTED_DELETE_COLUMN]) {
    suggestedValues['__deleted'] = fileRecord.updated_at;
  }

  return {
    id: {
      wsId: fileRecord[SCRATCH_ID_COLUMN] as SnapshotRecordId,
      remoteId: fileRecord[REMOTE_ID_COLUMN],
    },
    fields,
    __edited_fields: {},
    __suggested_values: suggestedValues,
    __fields: {},
    __metadata: {},
    __errors: (fileRecord[ERRORS_COLUMN] as RecordErrorsMetadata) || {},
    __dirty: fileRecord[DIRTY_COLUMN],
    __old_remote_id: null,
  };
}

export function slugifyFileName(text: string): string {
  return text
    .toString() // Ensure the input is a string
    .normalize('NFD') // Split accented letters into base letter and accent
    .replace(/[\u0300-\u036f]/g, '') // Remove all previously split accents (diacritical marks)
    .toLowerCase() // Convert to lowercase
    .trim() // Trim leading/trailing whitespace
    .replace(/\s+/g, '-') // Replace spaces with hyphens
    .replace(/[^a-z0-9 -]/g, '') // Remove all non-alphanumeric characters, except hyphens and spaces
    .replace(/-+/g, '-'); // Replace multiple hyphens with a single hyphen
}

export function getFolderIdFromPath(path: string): SnapshotTableId {
  return path.split('/')[1] as SnapshotTableId;
}

function assertPathIsValid(path: unknown): asserts path is string {
  if (typeof path !== 'string') {
    throw new Error(`Path must be a string, but got ${typeof path}: ${path as string}`);
  }
  if (path.length === 0) {
    throw new Error('Path must not be empty');
  }
  if (!path.startsWith('/')) {
    throw new Error('Path must start with a slash');
  }
}
