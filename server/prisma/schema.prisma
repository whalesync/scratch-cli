// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["relationJoins", "nativeDistinct"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

///
/// NOTE: Keep this in sync with packages/shared-types/src/enums
/// Begin "keep in sync" section
///

enum UserRole {
  USER
  ADMIN
}

enum TokenType {
  AGENT // For AI agents
  WEBSOCKET // For client web socket connections
  USER // For user API tokens
}

enum AiAgentCredentialSource {
  USER
  SYSTEM
}

enum Service {
  NOTION
  AIRTABLE
  CSV
  POSTGRES
  YOUTUBE
  WORDPRESS
  WEBFLOW
  WIX_BLOG
  AUDIENCEFUL
  MOCO
}

enum AuthType {
  API_KEY // Deprecated
  OAUTH
  USER_PROVIDED_PARAMS
}

enum ConnectorHealthStatus {
  OK
  FAILED
}

enum ActionType {
  PUBLISH
}

enum RecordDeleteBehavior {
  DELETE
  IGNORE
}

enum SyncState {
  OFF
  ON
}

enum SyncSide {
  SOURCE
  DESTINATION
}

///
/// End "keep in sync" section
///

model User {
  id                      String                   @id // type: UserId
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  clerkId                 String?                  @unique
  name                    String?
  email                   String?
  role                    UserRole                 @default(USER)
  stripeCustomerId        String?                  @unique
  organizationId          String?
  organization            Organization?            @relation(fields: [organizationId], references: [id], onDelete: SetNull)
  settings                Json?                    @default("{}") // UserSettings object
  lastWorkbookId          String?
  lastWorkbook            Workbook?                @relation("UserLastWorkbook", fields: [lastWorkbookId], references: [id], onDelete: SetNull)
  apiTokens               APIToken[]
  connectorAccounts       ConnectorAccount[]
  aiAgentCredentials      AiAgentCredential[]
  aiAgentTokenUsageEvents AiAgentTokenUsageEvent[]
  subscriptions           Subscription[]
  invoiceResults          InvoiceResult[]
  jobs                    DbJob[]
  workbooks               Workbook[]
}

model APIToken {
  id        String    @id // type: APITokenId
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  token     String
  createdAt DateTime  @default(now())
  expiresAt DateTime  @updatedAt
  type      TokenType @default(AGENT)
  scopes    String[] // Optional list of scopes for the token like 'read:snapshots', 'write:snapshots', ...

  @@unique([token])
  @@index([userId])
}

// Defines a set of credentials for the AI agent to use instead of the default ones, such as an OpenRouter API key
model AiAgentCredential {
  id                     String                  @id // type: AiAgentCredentialId
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  user                   User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                 String
  service                String
  apiKey                 String
  name                   String? // human readable name for the credential
  tokenUsageWarningLimit Int? // the token usage warning limit for the credential
  externalApiKeyId       String? // used to store the external ID or hash for an api key when generated via an SDK
  source                 AiAgentCredentialSource @default(USER) // where the api key came from user or system generated 
  default                Boolean                 @default(false)
  metadata               Json?                   @default("{}") // additional optional metadata for the credential, key-value pairs

  @@index([userId])
}

///
/// NOTE: Keep this in sync with packages/shared-types/src/db/connector-account.ts
/// Begin "keep in sync" section
///

model ConnectorAccount {
  id                        String                 @id // type: ConnectorAccountId
  createdAt                 DateTime               @default(now())
  updatedAt                 DateTime               @updatedAt
  user                      User?                  @relation(fields: [userId], references: [id], onDelete: SetNull)
  userId                    String?
  workbookId                String
  workbook                  Workbook               @relation(fields: [workbookId], references: [id], onDelete: Cascade)
  service                   Service
  displayName               String
  authType                  AuthType               @default(USER_PROVIDED_PARAMS)
  encryptedCredentials      Json                   @default("{}") // Encrypted JSON containing apiKey, oauth tokens, etc.
  healthStatus              ConnectorHealthStatus?
  healthStatusLastCheckedAt DateTime?
  healthStatusMessage       String? // Message if health status is not OK
  modifier                  String? // ID of the custom connector or other modifier entity
  extras                    Json? // Additional service-specific configuration
  dataFolders               DataFolder[]

  @@index([userId])
  @@index([workbookId])
}

///
/// End "keep in sync" section
///

///
/// NOTE: Keep this in sync with packages/shared-types/src/db/workbook.ts
/// Begin "keep in sync" section
///

model Workbook {
  id        String   @id // type: WorkbookId
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user           User?        @relation(fields: [userId], references: [id], onDelete: SetNull)
  userId         String?
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  dataFolders        DataFolder[]
  connectorAccounts  ConnectorAccount[]
  usersWithAsDefault User[]             @relation("UserLastWorkbook")

  @@index([userId])
  @@index([organizationId])
}

///
/// End "keep in sync" section
///

model AiAgentTokenUsageEvent {
  id             String   @id // type: AiAgentTokenUsageEventId
  credentialId   String? // type: AiAgentCredentialId
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  model          String
  requests       Int
  requestTokens  Int
  responseTokens Int
  totalTokens    Int
  context        Json? // additional context for the event

  @@index([userId])
  @@index([credentialId])
}

/// A user's subscription with stripe.
/// There *should* only ever be one of these for a user, but we track any subscriptions stripe sends our way.
model Subscription {
  id                   String       @id // type: SubscriptionId
  createdAt            DateTime     @default(now())
  updatedAt            DateTime     @updatedAt
  version              Int          @default(1)
  user                 User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId               String // the subscription must be assocated with a user that has the customer ID in Stripe
  organizationId       String
  organization         Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  planType             String       @default("NOT_MIGRATED") // values should match the the ScratchPlanType enum
  stripeSubscriptionId String       @unique
  expiration           DateTime
  priceInDollars       Int          @default(0)
  stripeStatus         String?
  cancelAt             DateTime? // set when the user has cancelled the subscription and the date it takes effect
  lastInvoicePaid      Boolean? /// Set when we receive invoice.paid or invoice.payment_failed webhooks.

  @@index([userId])
  @@index([organizationId])
}

/// Simple log to cache whether a user's subscription is getting paid.
/// Stripe is the authoritative source for this.
model InvoiceResult {
  id        String   @id // type: InvoiceResultId
  createdAt DateTime @default(now())

  /// Stripe invoice ID
  invoiceId String

  /// The user that the invoice is for.
  userId         String?
  user           User?        @relation(fields: [userId], references: [id], onDelete: SetNull)
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // True if the invoice was paid.
  succeeded Boolean

  @@index([userId])
  @@index([organizationId])
  @@index([invoiceId])
}

model DbJob {
  id        String  @id // type: JobId
  bullJobId String? // BullMQ job ID for tracking

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  progress    Json? // Job progress data
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  workbookId  String? // Optional workbook association for filtering
  status      String
  type        String
  data        Json // Job-specific data
  result      Json? // Job result data
  error       String? // Error message if failed
  processedOn DateTime? // When job actually started processing
  finishedOn  DateTime? // When job completed (success or failure)

  @@index([userId])
  @@index([workbookId])
  @@index([status])
  @@index([type])
  @@map("Job")
}

///
/// NOTE: Keep this in sync with packages/shared-types/src/db/audit-log-event.ts
/// Begin "keep in sync" section
///

model AuditLogEvent {
  id             String   @id // type: AuditLogEventId
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  userId         String? // user who triggered the event, don't use FK for this field
  organizationId String? // organization that owns the entity that was affected by this event, don't use FK for this field
  message        String // message describing the event
  eventType      String // create, update, delete, publish, etc.
  entityId       String // ID of the entity that was affected by this event like a workbook or connection
  context        Json? // Additional details about the event that can be used to to show what changed or store additional context

  @@index([userId])
  @@index([organizationId])
  @@index([entityId])
}

// DataFolder: An entity representing a collection of related files
// Two types of DataFolder:
//  - Linked Folder: A folder that is attached to a data source via a connectorAccount with a schema
//  - Scratch Folder: A folder that contains "local" folders for the user, not attached to an external data source
model DataFolder {
  id        String   @id // type: DataFolderId
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // A display name for the table, provided by the user or sourced from the data source table
  name String

  // Workbook ownership
  workbook   Workbook @relation(fields: [workbookId], references: [id], onDelete: Cascade)
  workbookId String

  // Optional connector account link
  connectorAccount   ConnectorAccount? @relation(fields: [connectorAccountId], references: [id], onDelete: SetNull)
  connectorAccountId String?

  // Service type (required when linked to a connector, optional otherwise)
  connectorService Service?

  // A schema object that describes the data in the files stored in the folder
  // Only used by Linked Folders
  schema              Json?
  lastSchemaRefreshAt DateTime

  // Optional folder hierarchy
  parent   DataFolder?  @relation("DataFolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  parentId String?
  children DataFolder[] @relation("DataFolderHierarchy")

  // Path of this folder in the File Store that contains the actual files
  path String?

  // Lock indicating an operation in progress: "pull", "publish", or null
  lock String?

  // Timestamp of the last successful sync (pull or publish)
  lastSyncTime DateTime?

  // Version number of the folder structure, to help with future migrations
  version Int @default(1)

  syncsPairsAsSource      SyncTablePair[]        @relation("sourceDataFolder")
  syncsPairsAsDestination SyncTablePair[]        @relation("destinationDataFolder")
  foreignKeyRecords       SyncForeignKeyRecord[]
  remoteIdMappings        SyncRemoteIdMapping[]

  // Table ID path for connectors that represent tables as a path (e.g., ["database", "schema", "table"])
  // Empty array for scratch folders, populated for linked folders
  tableId String[] @default([])

  @@unique([workbookId, parentId, name])
  @@index([workbookId])
  @@index([connectorAccountId])
  @@index([parentId])
  @@index([path])
}

///
/// End "keep in sync" section
///

///
/// NOTE: Keep this in sync with packages/shared-types/src/db/organization.ts
/// Begin "keep in sync" section
///

model Organization {
  id        String   @id // type: OrganizationId
  clerkId   String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String

  users          User[]
  workbooks      Workbook[]
  subscriptions  Subscription[]
  invoiceResults InvoiceResult[]
  actions        Action[]
}

///
/// End "keep in sync" section
///

/// Authorization codes for CLI login flow (similar to gcloud auth login)
model AuthorizationCode {
  id        String   @id // type: AuthorizationCodeId
  createdAt DateTime @default(now())
  expiresAt DateTime

  // The short user code displayed in CLI and entered by user in browser (e.g., "ABCD-1234")
  userCode String @unique

  // The longer code used by CLI to poll for authorization status
  pollingCode String @unique

  // Authorization status
  status String @default("pending") // "pending" | "approved" | "denied" | "expired"

  // Once approved, link to the user who authorized it
  userId String?

  // The generated API token (set when approved)
  apiToken String?

  @@index([userCode])
  @@index([pollingCode])
  @@index([expiresAt])
}

/// org's actions that are billable and we need to account for.
model Action {
  id             String       @id // type: ActionId
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId         String // User who initiated the action (no FK to avoid orphans)
  actionType     ActionType
  metadata       Json? // Dynamic data per action type

  @@index([organizationId, actionType, createdAt])
  @@index([organizationId, createdAt])
  @@index([userId, createdAt])
}

//#region Sync

/// Represents a one-way sync between two DataFolders
model Sync {
  id           String   @id // type: SyncId
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  displayName  String
  displayOrder Int      @default(0) @db.SmallInt

  // No default here, so the application should set a valid empty SyncMapping on creation
  mappings Json // SyncMapping - @see packages/shared-types/src/sync-mapping.ts

  /// Whether the sync is enabled.
  syncState            SyncState @default(OFF)
  /// The time the sync state was changed last.
  syncStateLastChanged DateTime?
  /// The time the most recent full sync was run.
  lastSyncTime         DateTime?

  syncTablePairs    SyncTablePair[]
  foreignKeyRecords SyncForeignKeyRecord[]
  remoteIdMappings  SyncRemoteIdMapping[]
}

model SyncTablePair {
  id        String   @id // type: SyncId
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sync   Sync   @relation(fields: [syncId], references: [id], onDelete: Cascade)
  syncId String

  sourceDataFolder   DataFolder @relation("sourceDataFolder", fields: [sourceDataFolderId], references: [id], onDelete: Cascade)
  sourceDataFolderId String

  destinationDataFolder   DataFolder @relation("destinationDataFolder", fields: [destinationDataFolderId], references: [id], onDelete: Cascade)
  destinationDataFolderId String
}

model SyncMatchKeys {
  // TODO: double check cuid IDs
  id String @id @default(cuid())

  // Intentionally without FKs here, because we only need this table as a dumb unique index
  syncId       String
  dataFolderId String
  matchId      String
  remoteId     String // The remote ID of the record (e.g., file path)

  @@unique([syncId, dataFolderId, matchId])
  @@index([syncId, matchId])
}

/// Caches JSON data of records referenced by foreign keys in source records.
/// For example, if a Post has category_id: "cat_123", this stores the Category record data.
model SyncForeignKeyRecord {
  // TODO: double check cuid IDs
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sync   Sync   @relation(fields: [syncId], references: [id], onDelete: Cascade)
  syncId String

  dataFolder   DataFolder @relation(fields: [dataFolderId], references: [id], onDelete: Cascade)
  dataFolderId String

  /// Whether foreignKeyId came from the source or destination
  /// This is somewhat redundant, since dataFolderId already associates it with a specific DataFolder
  side SyncSide

  /// The remote column ID for this specific foreign key on the source table
  foreignKeyColumnId String

  /// The foreign key value (remote ID of the referenced record)
  foreignKeyValue String

  /// JSON representation of the referenced record
  recordData Json

  @@unique([syncId, dataFolderId, foreignKeyColumnId, foreignKeyValue])
  @@index([syncId])
  @@index([dataFolderId])
}

/// Maps source remote IDs to destination remote IDs for synced records.
model SyncRemoteIdMapping {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sync   Sync   @relation(fields: [syncId], references: [id], onDelete: Cascade)
  syncId String

  dataFolder   DataFolder @relation(fields: [dataFolderId], references: [id], onDelete: Cascade)
  dataFolderId String

  /// The remote ID of the record in the source system
  sourceRemoteId String

  /// The remote ID of the corresponding record in the destination system (nullable for unmatched source records)
  destinationRemoteId String?

  @@unique([syncId, dataFolderId, sourceRemoteId])
  @@index([syncId])
  @@index([dataFolderId])
}

//#endregion
