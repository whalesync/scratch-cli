// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["relationJoins", "nativeDistinct"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  USER
  ADMIN
}

model User {
  id                      String                   @id // type: UserId
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  clerkId                 String?                  @unique
  name                    String?
  email                   String?
  role                    UserRole                 @default(USER)
  stripeCustomerId        String?                  @unique
  apiTokens               APIToken[]
  connectorAccounts       ConnectorAccount[]
  customConnectors        CustomConnector[]
  styleGuides             StyleGuide[]
  csvFiles                CsvFile[]
  aiAgentCredentials      AiAgentCredential[]
  aiAgentTokenUsageEvents AiAgentTokenUsageEvent[]
  subscriptions           Subscription[]
  invoiceResults          InvoiceResult[]
  jobs                    Job[]
}

enum TokenType {
  AGENT // For AI agents
  WEBSOCKET // For client web socket connections
  USER // For user API tokens
}

model APIToken {
  id        String    @id // type: APITokenId
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  token     String
  createdAt DateTime  @default(now())
  expiresAt DateTime  @updatedAt
  type      TokenType @default(AGENT)
  scopes    String[] // Optional list of scopes for the token like 'read:snapshots', 'write:snapshots', ...

  @@unique([token])
  @@index([userId])
}

enum AiAgentCredentialSource {
  USER
  SYSTEM
}

// Defines a set of credentials for the AI agent to use instead of the default ones, such as an OpenRouter API key
model AiAgentCredential {
  id               String                  @id // type: AiAgentCredentialId
  createdAt        DateTime                @default(now())
  updatedAt        DateTime                @updatedAt
  user             User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           String
  service          String
  apiKey           String
  description      String?
  externalApiKeyId String? // used to store the external ID or hash for an api key when generated via an SDK
  source           AiAgentCredentialSource @default(USER) // where the api key came from user or system generated 
  enabled          Boolean                 @default(true)

  @@index([userId])
}

model ConnectorAccount {
  id                        String                 @id // type: ConnectorAccountId
  createdAt                 DateTime               @default(now())
  updatedAt                 DateTime               @updatedAt
  user                      User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId                    String
  service                   Service
  displayName               String
  authType                  AuthType               @default(API_KEY)
  encryptedCredentials      Json                   @default("{}") // Encrypted JSON containing apiKey, oauth tokens, etc.
  healthStatus              ConnectorHealthStatus?
  healthStatusLastCheckedAt DateTime?
  modifier                  String? // ID of the custom connector or other modifier entity
  extras                    Json? // Additional service-specific configuration
  snapshots                 Snapshot[]
}

enum Service {
  NOTION
  AIRTABLE
  CUSTOM
  CSV
  POSTGRES
  YOUTUBE
}

enum AuthType {
  API_KEY
  OAUTH
}

enum ConnectorHealthStatus {
  OK
  FAILED
}

model Snapshot {
  id        String   @id // type: SnapshotId
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  connectorAccount   ConnectorAccount @relation(fields: [connectorAccountId], references: [id], onDelete: Cascade)
  connectorAccountId String

  tableSpecs Json[] // TableSpec[]

  tableContexts Json[] // SnapshotTableContext[]

  activeRecordFilter    Json? // {[tableId: string]: string[]}
  activeRecordSqlFilter Json? // {[tableId: string]: string}

  @@index([connectorAccountId])
}

model CustomConnector {
  id        String   @id // type: CustomConnectorId
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String
  mapping   Json? // Store the field mapping JSON
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String

  // AI generation prompt
  prompt String?

  // API key for external services
  apiKey String?

  // Table listing
  listTables String? // Store the table listing function body as text
  tables     String[] // Store the test table IDs we have fetched while building the connector

  // Schema generation
  fetchSchema String? // Store the schema generation function body as text
  schema      Json? // Store the result of schema generation

  // CRUD operation function bodies
  pollRecords         String? // Store the function body as text
  pollRecordsResponse Json?

  getRecord         String? // Store the function body as text
  getRecordResponse Json?

  deleteRecord String? // Store the function body as text
  createRecord String? // Store the function body as text
  updateRecord String?

  // Response schemas

  @@index([userId])
}

model StyleGuide {
  id               String    @id // type: StyleGuideId
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  name             String
  body             String // Markdown content
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           String
  autoInclude      Boolean   @default(false) // Whether to automatically include this style guide in conversations
  sourceUrl        String? // URL of where this resource an be download from
  contentType      String    @default("markdown") // "markdown" | "json" | "text"
  lastDownloadedAt DateTime? // When the resource was last downloaded
  tags             String[] // User defined tags for the resource

  @@index([userId])
}

model CsvFile {
  id        String   @id // type: CsvFileId
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String
  body      String // CSV content
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String

  @@index([userId])
}

model ColumnView {
  id         String   @id // type: ColumnViewId
  name       String? // Optional name for the view
  snapshotId String
  config     Json // ViewConfig
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([snapshotId])
}

model AiAgentTokenUsageEvent {
  id             String   @id // type: AiAgentTokenUsageEventId
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  model          String
  requests       Int
  requestTokens  Int
  responseTokens Int
  totalTokens    Int
  context        Json? // additional context for the event

  @@index([userId])
}

/// A user's subscription with stripe.
/// There *should* only ever be one of these for a user, but we track any subscriptions stripe sends our way.
model Subscription {
  id                   String   @id // type: SubscriptionId
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  version              Int      @default(1)
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId               String
  productType          String
  stripeSubscriptionId String   @unique
  expiration           DateTime
  priceInDollars       Int      @default(0)
  stripeStatus         String?
  /// Set when we receive invoice.paid or invoice.payment_failed webhooks.
  lastInvoicePaid      Boolean?

  @@index([userId])
}

/// Simple log to cache whether a user's subscription is getting paid.
/// Stripe is the authoritative source for this.
model InvoiceResult {
  id        String   @id // type: InvoiceResultId
  createdAt DateTime @default(now())

  /// Stripe invoice ID
  invoiceId String

  /// The user that the invoice is for.
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // True if the invoice was paid.
  succeeded Boolean
}

model AgentSession {
  id         String   @id // The session ID used by the pydantic agent
  userId     String // User ID for the session
  snapshotId String // Snapshot ID for the session
  data       Json // JSON data containing the session state
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([userId])
  @@index([snapshotId])
  @@index([userId, snapshotId])
}

enum JobStatus {
  PENDING
  ACTIVE
  COMPLETED
  FAILED
  CANCELLED
}

model Job {
  id          String    @id // type: JobId
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  status      JobStatus @default(PENDING)
  type        String
  data        Json // Job-specific data
  result      Json? // Job result data
  error       String? // Error message if failed
  startedAt   DateTime? // When job actually started processing
  completedAt DateTime? // When job completed (success or failure)
  bullJobId   String? // BullMQ job ID for tracking

  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([createdAt])
}
