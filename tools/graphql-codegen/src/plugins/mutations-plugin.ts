/**
 * Mutations Plugin
 *
 * Generates GraphQL mutation code and auto-detects read-only fields
 * by comparing entity output fields vs mutation input fields.
 */

import {
  GraphQLSchema,
  GraphQLObjectType,
  GraphQLInputObjectType,
  GraphQLField,
  isNonNullType,
  isInputObjectType,
  isObjectType,
  isListType,
} from 'graphql';
import { EntityConfig, MutationOutput } from '../types';

/**
 * Generate mutations for all writable entities
 */
export function generateMutations(
  schema: GraphQLSchema,
  entities: EntityConfig[],
): MutationOutput[] {
  const generator = new MutationsGenerator(schema);
  const outputs: MutationOutput[] = [];

  for (const entity of entities) {
    if (entity.readOnly || !entity.mutations) {
      continue;
    }

    const output = generator.generateForEntity(entity);
    if (output) {
      outputs.push(output);
    }
  }

  return outputs;
}

/**
 * Generate a mutation file for an entity
 */
export function generateMutationFile(output: MutationOutput, queryFieldsConstName: string): string {
  const constantName = toScreamingSnakeCase(output.entityType);
  const schemaFileName = output.entityType.replace(/_/g, '-');

  const mutationConsts: string[] = [];

  for (const mutation of output.mutations) {
    const constName = `${constantName}_${mutation.type.toUpperCase()}_MUTATION`;

    // For delete mutations, don't use query fields
    const mutationCode =
      mutation.type === 'delete'
        ? mutation.code
        : mutation.code.replace('${QUERY_FIELDS}', `\${${queryFieldsConstName}}`);

    mutationConsts.push(`/**
 * ${mutation.type.charAt(0).toUpperCase() + mutation.type.slice(1)} mutation for ${output.entityType}
 */
export const ${constName} = \`${mutationCode}\`;`);
  }

  // Import statement for query fields
  const importStatement =
    output.mutations.length > 0 && output.mutations.some((m) => m.type !== 'delete')
      ? `import { ${queryFieldsConstName} } from '../schemas/${schemaFileName}.schema';\n\n`
      : '';

  let content = `/**
 * Generated mutations for ${output.entityType}
 *
 * DO NOT EDIT - This file is auto-generated by the codegen script.
 * To regenerate, run: yarn codegen:shopify
 */

${importStatement}${mutationConsts.join('\n\n')}

/**
 * Fields that are read-only and should be stripped before mutations
 */
export const ${constantName}_READ_ONLY_FIELDS = new Set([
${output.readOnlyFields.map((f) => `  '${f}',`).join('\n')}
]);
`;

  // Add strip-on-update fields if present
  if (output.stripOnUpdateFields && output.stripOnUpdateFields.length > 0) {
    content += `
/**
 * Fields to strip on update only (required for create)
 */
export const ${constantName}_STRIP_ON_UPDATE_FIELDS = new Set([
${output.stripOnUpdateFields.map((f) => `  '${f}',`).join('\n')}
]);
`;
  }

  return content;
}

/**
 * Generate index file for all mutations
 */
export function generateMutationIndexFile(entityTypes: string[]): string {
  const exports = entityTypes.map((entityType) => {
    const fileName = entityType.replace(/_/g, '-');
    return `export * from './${fileName}.mutations';`;
  });

  return `/**
 * Generated Mutations Index
 *
 * DO NOT EDIT - This file is auto-generated by the codegen script.
 * To regenerate, run: yarn codegen:shopify
 */

${exports.join('\n')}
`;
}

// ============= Mutations Generator Class =============

class MutationsGenerator {
  private mutationType: GraphQLObjectType | null;

  constructor(private schema: GraphQLSchema) {
    this.mutationType = schema.getMutationType() || null;
  }

  /**
   * Generate mutation output for an entity
   */
  generateForEntity(entity: EntityConfig): MutationOutput | null {
    if (!entity.mutations || !this.mutationType) {
      console.log(`  Skipping ${entity.entityType}: ${!entity.mutations ? 'no mutations config' : 'no mutation type'}`);
      return null;
    }

    console.log(`  Processing ${entity.entityType}...`);

    const mutations: MutationOutput['mutations'] = [];
    let inputFieldNames: Set<string> = new Set();

    // Check if this entity uses bulk mutations
    const isBulk = entity.mutations.bulk === true;

    // Generate create mutation
    if (entity.mutations.create) {
      const createMutation = this.getMutationField(entity.mutations.create);
      if (createMutation) {
        const inputType = this.getInputType(createMutation);
        if (inputType) {
          inputFieldNames = this.getInputFieldNames(inputType);
          console.log(`  ${entity.mutations.create}: found ${inputFieldNames.size} input fields`);
        } else {
          console.warn(`  ${entity.mutations.create}: could not find input type`);
        }

        mutations.push({
          type: 'create',
          name: entity.mutations.create,
          code: isBulk
            ? this.generateBulkCreateMutation(entity, createMutation)
            : this.generateCreateMutation(entity, createMutation),
        });
      } else {
        console.warn(`  Mutation not found: ${entity.mutations.create}`);
      }
    }

    // Generate update mutation
    if (entity.mutations.update) {
      const updateMutation = this.getMutationField(entity.mutations.update);
      if (updateMutation) {
        // If we didn't get input fields from create, try update
        if (inputFieldNames.size === 0) {
          const inputType = this.getInputType(updateMutation);
          if (inputType) {
            inputFieldNames = this.getInputFieldNames(inputType);
            console.log(`  ${entity.mutations.update}: found ${inputFieldNames.size} input fields`);
          }
        }

        mutations.push({
          type: 'update',
          name: entity.mutations.update,
          code: isBulk
            ? this.generateBulkUpdateMutation(entity, updateMutation)
            : this.generateUpdateMutation(entity, updateMutation),
        });
      } else {
        console.warn(`  Mutation not found: ${entity.mutations.update}`);
      }
    }

    // Generate delete mutation
    if (entity.mutations.delete) {
      const deleteMutation = this.getMutationField(entity.mutations.delete);
      if (deleteMutation) {
        mutations.push({
          type: 'delete',
          name: entity.mutations.delete,
          code: isBulk
            ? this.generateBulkDeleteMutation(entity, deleteMutation)
            : this.generateDeleteMutation(entity, deleteMutation),
        });
      } else {
        console.warn(`  Mutation not found: ${entity.mutations.delete}`);
      }
    }

    if (mutations.length === 0) {
      console.log(`    No mutations generated for ${entity.entityType}`);
      return null;
    }

    // Compute read-only fields
    const readOnlyFields = this.computeReadOnlyFields(entity, inputFieldNames);

    console.log(`    Generated ${mutations.length} mutations, ${readOnlyFields.length} read-only fields`);

    return {
      entityType: entity.entityType,
      mutations,
      readOnlyFields,
      stripOnUpdateFields: entity.mutations.stripOnUpdateFields,
    };
  }

  private getMutationField(mutationName: string): GraphQLField<unknown, unknown> | null {
    if (!this.mutationType) return null;
    const fields = this.mutationType.getFields();
    return fields[mutationName] || null;
  }

  /**
   * Find the primary input type for a mutation.
   * Looks for any argument that is an InputObjectType, not just ones named "input".
   * Also handles bulk mutations where the input is wrapped in a list type.
   */
  private getInputType(mutation: GraphQLField<unknown, unknown>): GraphQLInputObjectType | null {
    // First try to find an argument named 'input' (most common)
    let inputArg = mutation.args.find((arg) => arg.name === 'input');

    // If not found, look for any InputObjectType argument (for page, blog, article, etc.)
    if (!inputArg) {
      inputArg = mutation.args.find((arg) => {
        const unwrapped = this.unwrapType(arg.type);
        return isInputObjectType(unwrapped);
      });
    }

    if (!inputArg) return null;

    // Unwrap the type (handles NonNull, List, or nested combinations)
    const unwrapped = this.unwrapType(inputArg.type);

    if (isInputObjectType(unwrapped)) {
      return unwrapped;
    }

    return null;
  }

  /**
   * Unwrap a type to get the underlying named type.
   * Handles NonNull and List wrappers (e.g., [SomeInput!]! -> SomeInput)
   */
  private unwrapType(type: unknown): unknown {
    let current = type;
    while (current) {
      if (isNonNullType(current)) {
        current = current.ofType;
      } else if (isListType(current)) {
        current = current.ofType;
      } else {
        break;
      }
    }
    return current;
  }

  /**
   * Get the primary input argument info (name and type name) for a mutation.
   */
  private getInputArgInfo(mutation: GraphQLField<unknown, unknown>): { argName: string; typeName: string } | null {
    // First try 'input', then any InputObjectType
    let inputArg = mutation.args.find((arg) => arg.name === 'input');

    if (!inputArg) {
      inputArg = mutation.args.find((arg) => {
        let argType = arg.type;
        if (isNonNullType(argType)) {
          argType = argType.ofType;
        }
        return isInputObjectType(argType);
      });
    }

    if (!inputArg) return null;

    let argType = inputArg.type;
    if (isNonNullType(argType)) {
      argType = argType.ofType;
    }

    const typeName = 'name' in argType ? argType.name : null;
    if (!typeName) return null;

    return { argName: inputArg.name, typeName };
  }

  private getInputFieldNames(inputType: GraphQLInputObjectType): Set<string> {
    const fields = inputType.getFields();
    return new Set(Object.keys(fields));
  }

  private computeReadOnlyFields(entity: EntityConfig, inputFieldNames: Set<string>): string[] {
    // If we couldn't find input fields, fall back to manually specified fields only
    if (inputFieldNames.size === 0) {
      console.warn(`  No input fields found for ${entity.entityType}, using manual read-only list`);
      const manual = entity.mutations?.additionalReadOnlyFields || [];
      return ['id', ...manual].sort();
    }

    // Get all fields from the output type
    const outputType = this.schema.getType(entity.graphqlType);
    if (!outputType || !isObjectType(outputType)) {
      return entity.mutations?.additionalReadOnlyFields || [];
    }

    const outputFields = outputType.getFields();
    const outputFieldNames = new Set(Object.keys(outputFields));

    // Read-only = fields in output but NOT in input
    const readOnlyFields = new Set<string>();

    for (const fieldName of outputFieldNames) {
      if (!inputFieldNames.has(fieldName)) {
        readOnlyFields.add(fieldName);
      }
    }

    // Always add 'id' as it's typically passed separately
    readOnlyFields.add('id');

    // Add any additional manually specified read-only fields
    if (entity.mutations?.additionalReadOnlyFields) {
      for (const field of entity.mutations.additionalReadOnlyFields) {
        readOnlyFields.add(field);
      }
    }

    return Array.from(readOnlyFields).sort();
  }

  private generateCreateMutation(
    entity: EntityConfig,
    mutation: GraphQLField<unknown, unknown>,
  ): string {
    const mutationName = mutation.name;
    const argInfo = this.getInputArgInfo(mutation);
    const argName = argInfo?.argName || 'input';
    const inputTypeName = argInfo?.typeName || `${entity.graphqlType}Input`;
    const outputFieldName = this.getOutputFieldName(entity.graphqlType);

    return `mutation ${toPascalCase(mutationName)}($${argName}: ${inputTypeName}!) {
  ${mutationName}(${argName}: $${argName}) {
    ${outputFieldName} {
      \${QUERY_FIELDS}
    }
    userErrors {
      field
      message
    }
  }
}`;
  }

  private generateUpdateMutation(
    entity: EntityConfig,
    mutation: GraphQLField<unknown, unknown>,
  ): string {
    const mutationName = mutation.name;
    const argInfo = this.getInputArgInfo(mutation);
    const argName = argInfo?.argName || 'input';
    const inputTypeName = argInfo?.typeName || `${entity.graphqlType}Input`;
    const outputFieldName = this.getOutputFieldName(entity.graphqlType);

    // Check if mutation has a separate 'id' argument
    const hasIdArg = mutation.args.some((arg) => arg.name === 'id');

    if (hasIdArg) {
      return `mutation ${toPascalCase(mutationName)}($id: ID!, $${argName}: ${inputTypeName}!) {
  ${mutationName}(id: $id, ${argName}: $${argName}) {
    ${outputFieldName} {
      \${QUERY_FIELDS}
    }
    userErrors {
      field
      message
    }
  }
}`;
    }

    return `mutation ${toPascalCase(mutationName)}($${argName}: ${inputTypeName}!) {
  ${mutationName}(${argName}: $${argName}) {
    ${outputFieldName} {
      \${QUERY_FIELDS}
    }
    userErrors {
      field
      message
    }
  }
}`;
  }

  private generateDeleteMutation(
    entity: EntityConfig,
    mutation: GraphQLField<unknown, unknown>,
  ): string {
    const mutationName = mutation.name;
    const deletedIdField = `deleted${entity.graphqlType}Id`;

    // Check if mutation has a separate 'id' argument (some use input object, some use direct id)
    const hasIdArg = mutation.args.some((arg) => arg.name === 'id');
    const argInfo = this.getInputArgInfo(mutation);

    if (hasIdArg && !argInfo) {
      // Direct id argument (e.g., pageDelete(id: ID!))
      return `mutation ${toPascalCase(mutationName)}($id: ID!) {
  ${mutationName}(id: $id) {
    ${deletedIdField}
    userErrors {
      field
      message
    }
  }
}`;
    }

    if (argInfo) {
      // Input object argument (e.g., productDelete(input: ProductDeleteInput!))
      return `mutation ${toPascalCase(mutationName)}($${argInfo.argName}: ${argInfo.typeName}!) {
  ${mutationName}(${argInfo.argName}: $${argInfo.argName}) {
    ${deletedIdField}
    userErrors {
      field
      message
    }
  }
}`;
    }

    // Fallback
    return `mutation ${toPascalCase(mutationName)}($id: ID!) {
  ${mutationName}(id: $id) {
    ${deletedIdField}
    userErrors {
      field
      message
    }
  }
}`;
  }

  private getOutputFieldName(graphqlType: string): string {
    return graphqlType.charAt(0).toLowerCase() + graphqlType.slice(1);
  }

  // ============= Bulk Mutation Generators =============

  /**
   * Generate bulk create mutation (e.g., productVariantsBulkCreate)
   * These take productId + array of variants
   */
  private generateBulkCreateMutation(
    entity: EntityConfig,
    mutation: GraphQLField<unknown, unknown>,
  ): string {
    const mutationName = mutation.name;
    const outputFieldName = this.getOutputFieldNamePlural(entity.graphqlType);
    const parentIdArg = this.getParentIdArgName(mutation);
    const inputArgInfo = this.getBulkInputArgInfo(mutation);

    const args: string[] = [];
    const params: string[] = [];

    if (parentIdArg) {
      args.push(`$${parentIdArg}: ID!`);
      params.push(`${parentIdArg}: $${parentIdArg}`);
    }

    if (inputArgInfo) {
      args.push(`$${inputArgInfo.argName}: ${inputArgInfo.typeName}`);
      params.push(`${inputArgInfo.argName}: $${inputArgInfo.argName}`);
    }

    return `mutation ${toPascalCase(mutationName)}(${args.join(', ')}) {
  ${mutationName}(${params.join(', ')}) {
    ${outputFieldName} {
      \${QUERY_FIELDS}
    }
    userErrors {
      field
      message
    }
  }
}`;
  }

  /**
   * Generate bulk update mutation (e.g., productVariantsBulkUpdate)
   */
  private generateBulkUpdateMutation(
    entity: EntityConfig,
    mutation: GraphQLField<unknown, unknown>,
  ): string {
    const mutationName = mutation.name;
    const outputFieldName = this.getOutputFieldNamePlural(entity.graphqlType);
    const parentIdArg = this.getParentIdArgName(mutation);
    const inputArgInfo = this.getBulkInputArgInfo(mutation);

    const args: string[] = [];
    const params: string[] = [];

    if (parentIdArg) {
      args.push(`$${parentIdArg}: ID!`);
      params.push(`${parentIdArg}: $${parentIdArg}`);
    }

    if (inputArgInfo) {
      args.push(`$${inputArgInfo.argName}: ${inputArgInfo.typeName}`);
      params.push(`${inputArgInfo.argName}: $${inputArgInfo.argName}`);
    }

    return `mutation ${toPascalCase(mutationName)}(${args.join(', ')}) {
  ${mutationName}(${params.join(', ')}) {
    ${outputFieldName} {
      \${QUERY_FIELDS}
    }
    userErrors {
      field
      message
    }
  }
}`;
  }

  /**
   * Generate bulk delete mutation (e.g., productVariantsBulkDelete)
   * These typically take productId + array of IDs to delete
   */
  private generateBulkDeleteMutation(
    entity: EntityConfig,
    mutation: GraphQLField<unknown, unknown>,
  ): string {
    const mutationName = mutation.name;
    const parentIdArg = this.getParentIdArgName(mutation);

    // Find the IDs array argument (e.g., variantsIds)
    const idsArg = mutation.args.find(
      (arg) => arg.name.endsWith('Ids') || arg.name === 'ids',
    );
    const idsArgName = idsArg?.name || 'ids';

    const args: string[] = [];
    const params: string[] = [];

    if (parentIdArg) {
      args.push(`$${parentIdArg}: ID!`);
      params.push(`${parentIdArg}: $${parentIdArg}`);
    }

    args.push(`$${idsArgName}: [ID!]!`);
    params.push(`${idsArgName}: $${idsArgName}`);

    return `mutation ${toPascalCase(mutationName)}(${args.join(', ')}) {
  ${mutationName}(${params.join(', ')}) {
    userErrors {
      field
      message
    }
  }
}`;
  }

  /**
   * Get the parent ID argument name (e.g., productId)
   */
  private getParentIdArgName(mutation: GraphQLField<unknown, unknown>): string | null {
    // Look for arguments ending with 'Id' that are ID type
    const idArg = mutation.args.find((arg) => {
      if (!arg.name.endsWith('Id')) return false;
      let argType = arg.type;
      if (isNonNullType(argType)) {
        argType = argType.ofType;
      }
      return 'name' in argType && argType.name === 'ID';
    });
    return idArg?.name || null;
  }

  /**
   * Get the bulk input argument info (e.g., variants: [ProductVariantsBulkInput!]!)
   */
  private getBulkInputArgInfo(mutation: GraphQLField<unknown, unknown>): { argName: string; typeName: string } | null {
    // Look for list type arguments that aren't ID arrays
    for (const arg of mutation.args) {
      // Skip ID arguments
      if (arg.name.endsWith('Id') || arg.name.endsWith('Ids')) continue;

      // Get the type string representation
      const typeStr = arg.type.toString();
      // Look for list types like [SomeInput!]!
      if (typeStr.startsWith('[') && typeStr.includes('Input')) {
        return { argName: arg.name, typeName: typeStr };
      }
    }
    return null;
  }

  /**
   * Get plural output field name (e.g., productVariants)
   */
  private getOutputFieldNamePlural(graphqlType: string): string {
    const singular = graphqlType.charAt(0).toLowerCase() + graphqlType.slice(1);
    return singular + 's';
  }
}

// ============= Utilities =============

function toPascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function toScreamingSnakeCase(str: string): string {
  return str.toUpperCase().replace(/-/g, '_');
}
