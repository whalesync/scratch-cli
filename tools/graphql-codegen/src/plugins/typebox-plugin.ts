/**
 * TypeBox Schema Plugin
 *
 * Generates TypeBox schemas and query field selection strings from GraphQL types.
 */

import {
  GraphQLSchema,
  GraphQLObjectType,
  GraphQLField,
  GraphQLOutputType,
  GraphQLNonNull,
  GraphQLList,
  GraphQLScalarType,
  GraphQLEnumType,
  GraphQLInterfaceType,
  GraphQLUnionType,
  isNonNullType,
  isListType,
  isScalarType,
  isEnumType,
  isObjectType,
  isInterfaceType,
  isUnionType,
  GraphQLNamedType,
  GraphQLAbstractType,
} from "graphql";
import {
  EntityConfig,
  FieldFilterConfig,
  ScalarMapping,
  TypeBoxSchemaOutput,
} from "../types";

/**
 * Generate TypeBox schemas for a list of entities
 */
export function generateTypeBoxSchemas(
  schema: GraphQLSchema,
  entities: EntityConfig[],
  scalarMappings: Record<string, ScalarMapping>,
  fieldFilters: FieldFilterConfig,
  interfaceImpls: Record<string, string[]>,
  maxDepth: number,
): TypeBoxSchemaOutput[] {
  const generator = new TypeBoxGenerator(
    schema,
    scalarMappings,
    fieldFilters,
    interfaceImpls,
    maxDepth,
  );
  const outputs: TypeBoxSchemaOutput[] = [];

  for (const entity of entities) {
    const graphqlType = schema.getType(entity.graphqlType);
    if (!graphqlType) {
      console.warn(`Type ${entity.graphqlType} not found in schema`);
      continue;
    }

    // Handle object types directly
    if (isObjectType(graphqlType)) {
      const schemaCode = generator.generateSchemaCode(graphqlType, entity);
      const queryFields = generator.generateQueryFields(graphqlType);

      outputs.push({
        entityType: entity.entityType,
        schemaCode,
        queryFields,
      });
      continue;
    }

    // Handle interface types by merging fields from implementations
    if (isInterfaceType(graphqlType)) {
      const result = generator.generateInterfaceSchemaCode(
        graphqlType,
        entity,
        interfaceImpls,
      );
      if (result) {
        outputs.push({
          entityType: entity.entityType,
          schemaCode: result.schemaCode,
          queryFields: result.queryFields,
        });
      }
      continue;
    }

    console.warn(
      `Type ${entity.graphqlType} is not an object or interface type`,
    );
  }

  return outputs;
}

/**
 * Generate a schema file for an entity
 */
export function generateSchemaFile(
  output: TypeBoxSchemaOutput,
  entity: EntityConfig,
): string {
  const pascalName = toPascalCase(output.entityType);
  const constantName = toScreamingSnakeCase(output.entityType);

  // Build config object as proper JS syntax
  const configLines: string[] = [];
  configLines.push(`  entityType: '${entity.entityType}',`);
  configLines.push(`  graphqlType: '${entity.graphqlType}',`);
  configLines.push(`  displayName: '${entity.displayName}',`);
  configLines.push(
    `  description: '${entity.description.replace(/'/g, "\\'")}',`,
  );
  configLines.push(`  readOnly: ${entity.readOnly},`);

  if (entity.columns) {
    const columnsLines: string[] = [];
    if (entity.columns.slug) {
      columnsLines.push(`    slug: '${entity.columns.slug}',`);
    }
    if (entity.columns.title) {
      const titles = entity.columns.title.map((t) => `'${t}'`).join(", ");
      columnsLines.push(`    title: [${titles}],`);
    }
    if (entity.columns.mainContent) {
      const contents = entity.columns.mainContent
        .map((c) => `'${c}'`)
        .join(", ");
      columnsLines.push(`    mainContent: [${contents}],`);
    }
    if (columnsLines.length > 0) {
      configLines.push(`  columns: {\n${columnsLines.join("\n")}\n  },`);
    }
  }

  // Add parent relationship info for normalized child tables
  if (entity.parent) {
    configLines.push(`  parent: {`);
    configLines.push(`    entityType: '${entity.parent.entityType}',`);
    configLines.push(`    foreignKey: '${entity.parent.foreignKey}',`);
    configLines.push(`    connectionField: '${entity.parent.connectionField}',`);
    configLines.push(`  },`);
  }

  // Add metadata flags
  if (entity.metadata) {
    const metadataLines: string[] = [];
    if (entity.metadata.plusOnly) {
      metadataLines.push(`    plusOnly: true,`);
    }
    if (metadataLines.length > 0) {
      configLines.push(`  metadata: {\n${metadataLines.join("\n")}\n  },`);
    }
  }

  return `/**
 * Generated TypeBox schema for ${entity.displayName}
 *
 * DO NOT EDIT - This file is auto-generated by the codegen script.
 * To regenerate, run: yarn codegen:shopify
 */

import { Type } from '@sinclair/typebox';

/**
 * TypeBox schema for ${entity.displayName}
 */
export const ${pascalName}Schema = ${output.schemaCode};

/**
 * GraphQL query field selection for ${entity.displayName}
 */
export const ${constantName}_QUERY_FIELDS = \`${output.queryFields}\`;

/**
 * Entity configuration for ${entity.displayName}
 */
export const ${constantName}_CONFIG = {
${configLines.join("\n")}
} as const;
`;
}

/**
 * Generate index file for all schemas
 */
export function generateSchemaIndexFile(entityTypes: string[]): string {
  const exports = entityTypes.map((entityType) => {
    const fileName = entityType.replace(/_/g, "-");
    return `export * from './${fileName}.schema';`;
  });

  return `/**
 * Generated Schema Index
 *
 * DO NOT EDIT - This file is auto-generated by the codegen script.
 * To regenerate, run: yarn codegen:shopify
 */

${exports.join("\n")}
`;
}

/**
 * Generate entity registry file that exports all entity configs as a unified registry
 */
export function generateEntityRegistryFile(entities: EntityConfig[]): string {
  const imports: string[] = [];
  const registryEntries: string[] = [];

  for (const entity of entities) {
    const constantName = toScreamingSnakeCase(entity.entityType);
    const fileName = entity.entityType.replace(/_/g, "-");

    imports.push(
      `import { ${constantName}_CONFIG } from './schemas/${fileName}.schema';`,
    );
    registryEntries.push(`  '${entity.entityType}': ${constantName}_CONFIG,`);
  }

  return `/**
 * Generated Entity Registry
 *
 * DO NOT EDIT - This file is auto-generated by the codegen script.
 * To regenerate, run: yarn codegen:shopify
 */

${imports.join("\n")}

/**
 * All entity configurations keyed by entity type
 */
export const ENTITY_REGISTRY = {
${registryEntries.join("\n")}
} as const;

/**
 * Type for entity types
 */
export type EntityType = keyof typeof ENTITY_REGISTRY;

/**
 * Array of all entity types (for iteration)
 */
export const ALL_ENTITY_TYPES = Object.keys(ENTITY_REGISTRY) as EntityType[];

/**
 * Get entity config by type
 */
export function getEntityConfig(entityType: EntityType) {
  return ENTITY_REGISTRY[entityType];
}

/**
 * Check if an entity is a child (has parent)
 */
export function isChildEntity(entityType: EntityType): boolean {
  return 'parent' in ENTITY_REGISTRY[entityType];
}

/**
 * Get parent entity type for a child entity
 */
export function getParentEntityType(entityType: EntityType): EntityType | null {
  const config = ENTITY_REGISTRY[entityType];
  if ('parent' in config && config.parent) {
    return config.parent.entityType as EntityType;
  }
  return null;
}
`;
}

// ============= TypeBox Generator Class =============

class TypeBoxGenerator {
  constructor(
    private schema: GraphQLSchema,
    private scalarMappings: Record<string, ScalarMapping>,
    private fieldFilters: FieldFilterConfig,
    private interfaceImpls: Record<string, string[]>,
    private maxDepth: number,
  ) {}

  /**
   * Generate TypeBox schema code for a GraphQL type
   */
  generateSchemaCode(type: GraphQLObjectType, entity: EntityConfig): string {
    const fields = type.getFields();
    const properties = this.generateProperties(fields, 1);

    return `Type.Object({
${properties}
}, {
  $id: 'shopify/${entity.entityType}',
  title: '${entity.displayName}',
})`;
  }

  /**
   * Generate query field selection string
   */
  generateQueryFields(type: GraphQLObjectType): string {
    return this.buildFieldSelection(type, 1);
  }

  /**
   * Generate schema code for an interface type by merging fields from implementations
   */
  generateInterfaceSchemaCode(
    interfaceType: GraphQLInterfaceType,
    entity: EntityConfig,
    interfaceImpls: Record<string, string[]>,
  ): { schemaCode: string; queryFields: string } | null {
    const implNames = interfaceImpls[interfaceType.name] || [];
    if (implNames.length === 0) {
      console.warn(
        `No implementations found for interface ${interfaceType.name}`,
      );
      return null;
    }

    // Collect all fields from implementations
    const allFields: Record<string, GraphQLField<unknown, unknown>> = {};

    // Start with interface's own fields
    const interfaceFields = interfaceType.getFields();
    Object.assign(allFields, interfaceFields);

    // Add fields from implementations
    for (const implName of implNames) {
      const implType = this.schema.getType(implName);
      if (implType && isObjectType(implType)) {
        Object.assign(allFields, implType.getFields());
      }
    }

    const properties = this.generateProperties(allFields, 1);
    const schemaCode = `Type.Object({
${properties}
}, {
  $id: 'shopify/${entity.entityType}',
  title: '${entity.displayName}',
})`;

    // Generate query fields with inline fragments for each implementation
    const queryFields = this.buildInterfaceQueryFields(
      interfaceType,
      implNames,
    );

    return { schemaCode, queryFields };
  }

  /**
   * Build query fields for an interface type using inline fragments
   */
  private buildInterfaceQueryFields(
    interfaceType: GraphQLInterfaceType,
    implNames: string[],
  ): string {
    const fragments: string[] = [];

    for (const implName of implNames) {
      const implType = this.schema.getType(implName);
      if (implType && isObjectType(implType)) {
        const fields = this.buildObjectFieldSelection(implType, 1);
        if (fields) {
          fragments.push(`... on ${implName} { ${fields} }`);
        }
      }
    }

    return fragments.join(" ");
  }

  private generateProperties(
    fields: Record<string, GraphQLField<unknown, unknown>>,
    depth: number,
  ): string {
    const lines: string[] = [];
    const indent = "  ".repeat(depth);

    for (const [name, field] of Object.entries(fields)) {
      if (this.shouldSkipField(name, field)) {
        continue;
      }

      const fieldType = this.generateFieldType(field.type, depth);

      if (name === "id") {
        lines.push(`${indent}${name}: ${fieldType},`);
      } else {
        lines.push(`${indent}${name}: Type.Optional(${fieldType}),`);
      }
    }

    return lines.join("\n");
  }

  private generateFieldType(type: GraphQLOutputType, depth: number): string {
    // Unwrap NonNull
    if (isNonNullType(type)) {
      return this.generateFieldType(type.ofType, depth);
    }

    // Handle List
    if (isListType(type)) {
      const innerType = this.generateFieldType(type.ofType, depth);
      return `Type.Array(${innerType})`;
    }

    // Handle Scalar
    if (isScalarType(type)) {
      return this.generateScalarType(type);
    }

    // Handle Enum
    if (isEnumType(type)) {
      return "Type.Union([Type.String(), Type.Null()])";
    }

    // Handle Object/Interface/Union (nested types)
    if (isObjectType(type) || isInterfaceType(type) || isUnionType(type)) {
      if (
        depth >= this.maxDepth ||
        this.fieldFilters.skipExpansionTypes.has(type.name)
      ) {
        return "Type.Unknown()";
      }

      const nestedType = this.generateNestedObjectType(type, depth + 1);
      return `Type.Union([${nestedType}, Type.Null()])`;
    }

    return "Type.Unknown()";
  }

  private generateNestedObjectType(
    type: GraphQLObjectType | GraphQLInterfaceType | GraphQLUnionType,
    depth: number,
  ): string {
    // For interfaces/unions, merge fields from implementations
    if (isInterfaceType(type) || isUnionType(type)) {
      const impls = this.interfaceImpls[type.name] || [];
      if (impls.length === 0) {
        return "Type.Unknown()";
      }

      const allFields: Record<string, GraphQLField<unknown, unknown>> = {};
      for (const implName of impls) {
        const implType = this.schema.getType(implName);
        if (implType && isObjectType(implType)) {
          Object.assign(allFields, implType.getFields());
        }
      }

      const props = this.generateNestedProperties(allFields, depth);
      return `Type.Object({ ${props} })`;
    }

    // Regular object type
    const props = this.generateNestedProperties(type.getFields(), depth);
    return `Type.Object({ ${props} })`;
  }

  private generateNestedProperties(
    fields: Record<string, GraphQLField<unknown, unknown>>,
    depth: number,
  ): string {
    const props: string[] = [];

    for (const [name, field] of Object.entries(fields)) {
      if (this.shouldSkipField(name, field)) {
        continue;
      }

      const fieldType = this.generateFieldType(field.type, depth);
      props.push(`${name}: Type.Optional(${fieldType})`);
    }

    return props.join(", ");
  }

  private generateScalarType(type: GraphQLScalarType): string {
    const mapping = this.scalarMappings[type.name];
    if (!mapping) {
      return "Type.Union([Type.String(), Type.Null()])";
    }

    let baseType: string;
    switch (mapping.typeboxType) {
      case "string":
        baseType = mapping.format
          ? `Type.String({ format: '${mapping.format}' })`
          : "Type.String()";
        break;
      case "number":
        baseType = "Type.Number()";
        break;
      case "boolean":
        baseType = "Type.Boolean()";
        break;
      case "unknown":
        baseType = "Type.Unknown()";
        break;
      default:
        baseType = "Type.String()";
    }

    if (mapping.nullable) {
      return `Type.Union([${baseType}, Type.Null()])`;
    }
    return baseType;
  }

  private shouldSkipField(
    name: string,
    field: GraphQLField<unknown, unknown>,
  ): boolean {
    if (this.fieldFilters.skipFields.has(name)) return true;
    if (this.fieldFilters.skipConnections.has(name)) return true;
    if (this.fieldFilters.fieldsRequiringArgs.has(name)) return true;
    if (field.args && field.args.length > 0) {
      // Skip fields with required arguments
      const hasRequiredArgs = field.args.some((arg) => isNonNullType(arg.type));
      if (hasRequiredArgs) return true;
    }
    return false;
  }

  // ============= Query Field Selection =============

  private buildFieldSelection(type: GraphQLObjectType, depth: number): string {
    const fields = type.getFields();
    const selections: string[] = [];

    for (const [name, field] of Object.entries(fields)) {
      if (this.shouldSkipField(name, field)) {
        continue;
      }

      const selection = this.buildFieldSelectionForField(name, field, depth);
      if (selection) {
        selections.push(selection);
      }
    }

    return selections.join(" ");
  }

  private buildFieldSelectionForField(
    name: string,
    field: GraphQLField<unknown, unknown>,
    depth: number,
  ): string | null {
    const fieldType = this.unwrapType(field.type);

    // Reference-only fields just get { id }
    if (this.fieldFilters.referenceOnlyFields.has(name)) {
      return `${name} { id }`;
    }

    // Scalar/enum fields - just the name
    if (isScalarType(fieldType) || isEnumType(fieldType)) {
      return name;
    }

    // Nested object types
    if (
      isObjectType(fieldType) ||
      isInterfaceType(fieldType) ||
      isUnionType(fieldType)
    ) {
      if (
        depth >= this.maxDepth ||
        this.fieldFilters.skipExpansionTypes.has(fieldType.name)
      ) {
        return null;
      }

      const nestedSelection = this.buildNestedSelection(fieldType, depth + 1);
      if (nestedSelection) {
        return `${name} { ${nestedSelection} }`;
      }
      return null;
    }

    return name;
  }

  private buildNestedSelection(
    type: GraphQLNamedType,
    depth: number,
  ): string | null {
    if (depth > this.maxDepth) {
      return null;
    }

    // For interfaces/unions, use inline fragments
    if (isInterfaceType(type) || isUnionType(type)) {
      const impls = this.interfaceImpls[type.name] || [];
      if (impls.length === 0) {
        return null;
      }

      const fragments: string[] = [];
      for (const implName of impls) {
        const implType = this.schema.getType(implName);
        if (implType && isObjectType(implType)) {
          const fields = this.buildObjectFieldSelection(implType, depth);
          if (fields) {
            fragments.push(`... on ${implName} { ${fields} }`);
          }
        }
      }
      return fragments.join(" ");
    }

    if (isObjectType(type)) {
      return this.buildObjectFieldSelection(type, depth);
    }

    return null;
  }

  private buildObjectFieldSelection(
    type: GraphQLObjectType,
    depth: number,
  ): string | null {
    const fields = type.getFields();
    const selections: string[] = [];

    for (const [name, field] of Object.entries(fields)) {
      if (this.shouldSkipField(name, field)) {
        continue;
      }

      const fieldType = this.unwrapType(field.type);

      if (isScalarType(fieldType) || isEnumType(fieldType)) {
        selections.push(name);
      } else if (
        depth < this.maxDepth &&
        !this.fieldFilters.skipExpansionTypes.has(fieldType.name)
      ) {
        // For nested objects, only go one more level
        if (isObjectType(fieldType)) {
          const nestedFields = Object.entries(fieldType.getFields())
            .filter(([n, f]) => !this.shouldSkipField(n, f))
            .filter(([, f]) => {
              const t = this.unwrapType(f.type);
              return isScalarType(t) || isEnumType(t);
            })
            .map(([n]) => n);

          if (nestedFields.length > 0) {
            selections.push(`${name} { ${nestedFields.join(" ")} }`);
          }
        }
      }
    }

    return selections.length > 0 ? selections.join(" ") : null;
  }

  private unwrapType(type: GraphQLOutputType): GraphQLNamedType {
    if (isNonNullType(type) || isListType(type)) {
      return this.unwrapType(type.ofType);
    }
    return type as GraphQLNamedType;
  }
}

// ============= Utilities =============

function toPascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join("");
}

function toScreamingSnakeCase(str: string): string {
  return str.toUpperCase().replace(/-/g, "_");
}
